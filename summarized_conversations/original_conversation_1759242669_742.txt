{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/lending-borrowing-admin/src/main.py">\n"""\nTigerEx Lending & Borrowing Admin Panel\nManages lending pools, borrowing positions, and interest rates\nPort: 8121\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_lending_borrowing"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass PoolStatus(str, Enum):\n    ACTIVE = "active"\n    PAUSED = "paused"\n    CLOSED = "closed"\n\nclass LendingPool(Base):\n    __tablename__ = "lending_pools"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    asset = Column(String, unique=True, index=True)\n    total_supplied = Column(Float, default=0.0)\n    total_borrowed = Column(Float, default=0.0)\n    available_liquidity = Column(Float, default=0.0)\n    utilization_rate = Column(Float, default=0.0)\n    supply_apy = Column(Float, default=0.0)\n    borrow_apy = Column(Float, default=0.0)\n    ltv_ratio = Column(Float, default=0.75)\n    liquidation_threshold = Column(Float, default=0.85)\n    liquidation_penalty = Column(Float, default=0.05)\n    status = Column(String, default="active")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass LendingPosition(Base):\n    __tablename__ = "lending_positions"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, index=True)\n    pool_id = Column(Integer, index=True)\n    amount = Column(Float)\n    apy = Column(Float)\n    accrued_interest = Column(Float, default=0.0)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass BorrowingPosition(Base):\n    __tablename__ = "borrowing_positions"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, index=True)\n    pool_id = Column(Integer, index=True)\n    borrowed_amount = Column(Float)\n    collateral_amount = Column(Float)\n    collateral_asset = Column(String)\n    apy = Column(Float)\n    accrued_interest = Column(Float, default=0.0)\n    health_factor = Column(Float, default=1.0)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    liquidated_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nBase.metadata.create_all(bind=engine)\n\nclass LendingPoolCreate(BaseModel):\n    asset: str\n    supply_apy: float = Field(ge=0, le=100, default=5.0)\n    borrow_apy: float = Field(ge=0, le=100, default=8.0)\n    ltv_ratio: float = Field(ge=0, le=1, default=0.75)\n    liquidation_threshold: float = Field(ge=0, le=1, default=0.85)\n    liquidation_penalty: float = Field(ge=0, le=1, default=0.05)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass LendingPoolUpdate(BaseModel):\n    supply_apy: Optional[float] = None\n    borrow_apy: Optional[float] = None\n    ltv_ratio: Optional[float] = None\n    liquidation_threshold: Optional[float] = None\n    liquidation_penalty: Optional[float] = None\n    status: Optional[PoolStatus] = None\n    metadata: Optional[Dict[str, Any]] = None\n\napp = FastAPI(title="TigerEx Lending & Borrowing Admin API", version="1.0.0")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post("/api/admin/pools", status_code=201)\nasync def create_pool(pool: LendingPoolCreate, db: Session = Depends(get_db)):\n    """Create a new lending pool"""\n    try:\n        existing = db.query(LendingPool).filter(LendingPool.asset == pool.asset).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Pool already exists")\n        \n        db_pool = LendingPool(**pool.dict())\n        db.add(db_pool)\n        db.commit()\n        db.refresh(db_pool)\n        \n        logger.info(f"Created lending pool: {pool.asset}")\n        return db_pool\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating pool: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/pools")\nasync def get_pools(\n    skip: int = 0,\n    limit: int = 100,\n    status: Optional[PoolStatus] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all lending pools"""\n    try:\n        query = db.query(LendingPool)\n        \n        if status:\n            query = query.filter(LendingPool.status == status)\n        \n        total = query.count()\n        pools = query.order_by(LendingPool.total_supplied.desc()).offset(skip).limit(limit).all()\n        \n        return {"total": total, "pools": pools}\n    except Exception as e:\n        logger.error(f"Error fetching pools: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.put("/api/admin/pools/{pool_id}")\nasync def update_pool(\n    pool_id: int,\n    pool_update: LendingPoolUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a lending pool"""\n    try:\n        pool = db.query(LendingPool).filter(LendingPool.id == pool_id).first()\n        if not pool:\n            raise HTTPException(status_code=404, detail="Pool not found")\n        \n        update_data = pool_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(pool, field, value)\n        \n        db.commit()\n        db.refresh(pool)\n        \n        logger.info(f"Updated pool: {pool_id}")\n        return pool\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating pool: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get lending & borrowing analytics"""\n    try:\n        total_pools = db.query(LendingPool).count()\n        active_pools = db.query(LendingPool).filter(LendingPool.status == "active").count()\n        total_supplied = db.query(LendingPool).with_entities(\n            db.func.sum(LendingPool.total_supplied)\n        ).scalar() or 0.0\n        total_borrowed = db.query(LendingPool).with_entities(\n            db.func.sum(LendingPool.total_borrowed)\n        ).scalar() or 0.0\n        avg_utilization = db.query(LendingPool).filter(\n            LendingPool.status == "active"\n        ).with_entities(db.func.avg(LendingPool.utilization_rate)).scalar() or 0.0\n        \n        return {\n            "total_pools": total_pools,\n            "active_pools": active_pools,\n            "total_supplied": total_supplied,\n            "total_borrowed": total_borrowed,\n            "avg_utilization": avg_utilization\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "lending-borrowing-admin"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8121)\n</create-file>\n</function_calls>'}