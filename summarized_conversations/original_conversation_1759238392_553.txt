{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/launchpad-service/main.py">\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport uuid\nimport logging\nfrom sqlalchemy import create_engine, Column, String, Float, Integer, DateTime, Boolean, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title="Launchpad Service", version="1.0.0")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/launchpad"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Database Models\nclass LaunchpadProjectDB(Base):\n    __tablename__ = "launchpad_projects"\n    \n    id = Column(String, primary_key=True)\n    name = Column(String, nullable=False)\n    symbol = Column(String, nullable=False)\n    description = Column(Text, nullable=False)\n    website = Column(String, nullable=True)\n    whitepaper = Column(String, nullable=True)\n    total_supply = Column(Float, nullable=False)\n    sale_supply = Column(Float, nullable=False)\n    token_price = Column(Float, nullable=False)\n    hard_cap = Column(Float, nullable=False)\n    soft_cap = Column(Float, nullable=False)\n    min_allocation = Column(Float, default=0.0)\n    max_allocation = Column(Float, nullable=True)\n    start_date = Column(DateTime, nullable=False)\n    end_date = Column(DateTime, nullable=False)\n    vesting_schedule = Column(Text, nullable=True)\n    status = Column(String, default="upcoming")  # upcoming, active, completed, cancelled\n    total_raised = Column(Float, default=0.0)\n    participants_count = Column(Integer, default=0)\n    kyc_required = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass LaunchpadParticipationDB(Base):\n    __tablename__ = "launchpad_participations"\n    \n    id = Column(String, primary_key=True)\n    project_id = Column(String, nullable=False, index=True)\n    user_id = Column(String, nullable=False, index=True)\n    amount_invested = Column(Float, nullable=False)\n    tokens_allocated = Column(Float, nullable=False)\n    payment_currency = Column(String, default="USDT")\n    kyc_verified = Column(Boolean, default=False)\n    status = Column(String, default="pending")  # pending, confirmed, refunded\n    transaction_hash = Column(String, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass TokenVestingDB(Base):\n    __tablename__ = "token_vesting"\n    \n    id = Column(String, primary_key=True)\n    participation_id = Column(String, nullable=False, index=True)\n    user_id = Column(String, nullable=False, index=True)\n    project_id = Column(String, nullable=False)\n    total_tokens = Column(Float, nullable=False)\n    claimed_tokens = Column(Float, default=0.0)\n    next_unlock_date = Column(DateTime, nullable=True)\n    next_unlock_amount = Column(Float, default=0.0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Pydantic Models\nclass ProjectStatus(str, Enum):\n    UPCOMING = "upcoming"\n    ACTIVE = "active"\n    COMPLETED = "completed"\n    CANCELLED = "cancelled"\n\nclass LaunchpadProjectCreate(BaseModel):\n    name: str\n    symbol: str\n    description: str\n    website: Optional[str] = None\n    whitepaper: Optional[str] = None\n    total_supply: float = Field(gt=0)\n    sale_supply: float = Field(gt=0)\n    token_price: float = Field(gt=0)\n    hard_cap: float = Field(gt=0)\n    soft_cap: float = Field(gt=0)\n    min_allocation: float = Field(ge=0)\n    max_allocation: Optional[float] = None\n    start_date: datetime\n    end_date: datetime\n    vesting_schedule: Optional[str] = None\n    kyc_required: bool = True\n\nclass LaunchpadProjectResponse(BaseModel):\n    id: str\n    name: str\n    symbol: str\n    description: str\n    website: Optional[str]\n    whitepaper: Optional[str]\n    total_supply: float\n    sale_supply: float\n    token_price: float\n    hard_cap: float\n    soft_cap: float\n    min_allocation: float\n    max_allocation: Optional[float]\n    start_date: datetime\n    end_date: datetime\n    vesting_schedule: Optional[str]\n    status: str\n    total_raised: float\n    participants_count: int\n    kyc_required: bool\n    progress_percentage: float\n    created_at: datetime\n\nclass ParticipateRequest(BaseModel):\n    project_id: str\n    amount: float = Field(gt=0)\n    payment_currency: str = "USDT"\n\nclass ParticipationResponse(BaseModel):\n    id: str\n    project_id: str\n    user_id: str\n    amount_invested: float\n    tokens_allocated: float\n    payment_currency: str\n    kyc_verified: bool\n    status: str\n    created_at: datetime\n\nclass VestingResponse(BaseModel):\n    id: str\n    participation_id: str\n    user_id: str\n    project_id: str\n    total_tokens: float\n    claimed_tokens: float\n    remaining_tokens: float\n    next_unlock_date: Optional[datetime]\n    next_unlock_amount: float\n\n# API Endpoints\n@app.post("/projects", response_model=LaunchpadProjectResponse)\nasync def create_project(project: LaunchpadProjectCreate, db: Session = Depends(get_db)):\n    """Create a launchpad project"""\n    project_id = str(uuid.uuid4())\n    \n    # Determine initial status based on dates\n    now = datetime.utcnow()\n    if now < project.start_date:\n        status = "upcoming"\n    elif now >= project.start_date and now <= project.end_date:\n        status = "active"\n    else:\n        status = "completed"\n    \n    db_project = LaunchpadProjectDB(\n        id=project_id,\n        name=project.name,\n        symbol=project.symbol,\n        description=project.description,\n        website=project.website,\n        whitepaper=project.whitepaper,\n        total_supply=project.total_supply,\n        sale_supply=project.sale_supply,\n        token_price=project.token_price,\n        hard_cap=project.hard_cap,\n        soft_cap=project.soft_cap,\n        min_allocation=project.min_allocation,\n        max_allocation=project.max_allocation,\n        start_date=project.start_date,\n        end_date=project.end_date,\n        vesting_schedule=project.vesting_schedule,\n        status=status,\n        kyc_required=project.kyc_required,\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(db_project)\n    db.commit()\n    db.refresh(db_project)\n    \n    progress = (db_project.total_raised / db_project.hard_cap * 100) if db_project.hard_cap > 0 else 0\n    \n    return LaunchpadProjectResponse(\n        id=db_project.id,\n        name=db_project.name,\n        symbol=db_project.symbol,\n        description=db_project.description,\n        website=db_project.website,\n        whitepaper=db_project.whitepaper,\n        total_supply=db_project.total_supply,\n        sale_supply=db_project.sale_supply,\n        token_price=db_project.token_price,\n        hard_cap=db_project.hard_cap,\n        soft_cap=db_project.soft_cap,\n        min_allocation=db_project.min_allocation,\n        max_allocation=db_project.max_allocation,\n        start_date=db_project.start_date,\n        end_date=db_project.end_date,\n        vesting_schedule=db_project.vesting_schedule,\n        status=db_project.status,\n        total_raised=db_project.total_raised,\n        participants_count=db_project.participants_count,\n        kyc_required=db_project.kyc_required,\n        progress_percentage=progress,\n        created_at=db_project.created_at\n    )\n\n@app.get("/projects", response_model=List[LaunchpadProjectResponse])\nasync def list_projects(status: Optional[str] = None, db: Session = Depends(get_db)):\n    """List all launchpad projects"""\n    query = db.query(LaunchpadProjectDB)\n    \n    if status:\n        query = query.filter(LaunchpadProjectDB.status == status)\n    \n    projects = query.order_by(LaunchpadProjectDB.start_date.desc()).all()\n    \n    return [LaunchpadProjectResponse(\n        id=p.id,\n        name=p.name,\n        symbol=p.symbol,\n        description=p.description,\n        website=p.website,\n        whitepaper=p.whitepaper,\n        total_supply=p.total_supply,\n        sale_supply=p.sale_supply,\n        token_price=p.token_price,\n        hard_cap=p.hard_cap,\n        soft_cap=p.soft_cap,\n        min_allocation=p.min_allocation,\n        max_allocation=p.max_allocation,\n        start_date=p.start_date,\n        end_date=p.end_date,\n        vesting_schedule=p.vesting_schedule,\n        status=p.status,\n        total_raised=p.total_raised,\n        participants_count=p.participants_count,\n        kyc_required=p.kyc_required,\n        progress_percentage=(p.total_raised / p.hard_cap * 100) if p.hard_cap > 0 else 0,\n        created_at=p.created_at\n    ) for p in projects]\n\n@app.get("/projects/{project_id}", response_model=LaunchpadProjectResponse)\nasync def get_project(project_id: str, db: Session = Depends(get_db)):\n    """Get project details"""\n    project = db.query(LaunchpadProjectDB).filter(LaunchpadProjectDB.id == project_id).first()\n    if not project:\n        raise HTTPException(status_code=404, detail="Project not found")\n    \n    progress = (project.total_raised / project.hard_cap * 100) if project.hard_cap > 0 else 0\n    \n    return LaunchpadProjectResponse(\n        id=project.id,\n        name=project.name,\n        symbol=project.symbol,\n        description=project.description,\n        website=project.website,\n        whitepaper=project.whitepaper,\n        total_supply=project.total_supply,\n        sale_supply=project.sale_supply,\n        token_price=project.token_price,\n        hard_cap=project.hard_cap,\n        soft_cap=project.soft_cap,\n        min_allocation=project.min_allocation,\n        max_allocation=project.max_allocation,\n        start_date=project.start_date,\n        end_date=project.end_date,\n        vesting_schedule=project.vesting_schedule,\n        status=project.status,\n        total_raised=project.total_raised,\n        participants_count=project.participants_count,\n        kyc_required=project.kyc_required,\n        progress_percentage=progress,\n        created_at=project.created_at\n    )\n\n@app.post("/participate", response_model=ParticipationResponse)\nasync def participate(request: ParticipateRequest, user_id: str = "user123", db: Session = Depends(get_db)):\n    """Participate in a launchpad project"""\n    project = db.query(LaunchpadProjectDB).filter(LaunchpadProjectDB.id == request.project_id).first()\n    if not project:\n        raise HTTPException(status_code=404, detail="Project not found")\n    \n    if project.status != "active":\n        raise HTTPException(status_code=400, detail="Project is not active")\n    \n    now = datetime.utcnow()\n    if now < project.start_date or now > project.end_date:\n        raise HTTPException(status_code=400, detail="Project sale period has ended")\n    \n    if request.amount < project.min_allocation:\n        raise HTTPException(status_code=400, detail=f"Minimum allocation is {project.min_allocation}")\n    \n    if project.max_allocation and request.amount > project.max_allocation:\n        raise HTTPException(status_code=400, detail=f"Maximum allocation is {project.max_allocation}")\n    \n    if project.total_raised + request.amount > project.hard_cap:\n        raise HTTPException(status_code=400, detail="Hard cap reached")\n    \n    # Calculate tokens allocated\n    tokens_allocated = request.amount / project.token_price\n    \n    participation_id = str(uuid.uuid4())\n    participation = LaunchpadParticipationDB(\n        id=participation_id,\n        project_id=request.project_id,\n        user_id=user_id,\n        amount_invested=request.amount,\n        tokens_allocated=tokens_allocated,\n        payment_currency=request.payment_currency,\n        kyc_verified=not project.kyc_required,  # Auto-verify if KYC not required\n        status="confirmed",\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(participation)\n    \n    # Update project stats\n    project.total_raised += request.amount\n    project.participants_count += 1\n    \n    # Create vesting schedule\n    vesting_id = str(uuid.uuid4())\n    vesting = TokenVestingDB(\n        id=vesting_id,\n        participation_id=participation_id,\n        user_id=user_id,\n        project_id=request.project_id,\n        total_tokens=tokens_allocated,\n        next_unlock_date=project.end_date + timedelta(days=30),  # First unlock after 30 days\n        next_unlock_amount=tokens_allocated * 0.25,  # 25% unlock\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(vesting)\n    db.commit()\n    db.refresh(participation)\n    \n    return ParticipationResponse(\n        id=participation.id,\n        project_id=participation.project_id,\n        user_id=participation.user_id,\n        amount_invested=participation.amount_invested,\n        tokens_allocated=participation.tokens_allocated,\n        payment_currency=participation.payment_currency,\n        kyc_verified=participation.kyc_verified,\n        status=participation.status,\n        created_at=participation.created_at\n    )\n\n@app.get("/participations", response_model=List[ParticipationResponse])\nasync def list_participations(user_id: str = "user123", db: Session = Depends(get_db)):\n    """List user participations"""\n    participations = db.query(LaunchpadParticipationDB).filter(\n        LaunchpadParticipationDB.user_id == user_id\n    ).all()\n    \n    return [ParticipationResponse(\n        id=p.id,\n        project_id=p.project_id,\n        user_id=p.user_id,\n        amount_invested=p.amount_invested,\n        tokens_allocated=p.tokens_allocated,\n        payment_currency=p.payment_currency,\n        kyc_verified=p.kyc_verified,\n        status=p.status,\n        created_at=p.created_at\n    ) for p in participations]\n\n@app.get("/vesting", response_model=List[VestingResponse])\nasync def list_vesting(user_id: str = "user123", db: Session = Depends(get_db)):\n    """List user vesting schedules"""\n    vestings = db.query(TokenVestingDB).filter(TokenVestingDB.user_id == user_id).all()\n    \n    return [VestingResponse(\n        id=v.id,\n        participation_id=v.participation_id,\n        user_id=v.user_id,\n        project_id=v.project_id,\n        total_tokens=v.total_tokens,\n        claimed_tokens=v.claimed_tokens,\n        remaining_tokens=v.total_tokens - v.claimed_tokens,\n        next_unlock_date=v.next_unlock_date,\n        next_unlock_amount=v.next_unlock_amount\n    ) for v in vestings]\n\n@app.post("/vesting/{vesting_id}/claim")\nasync def claim_tokens(vesting_id: str, user_id: str = "user123", db: Session = Depends(get_db)):\n    """Claim vested tokens"""\n    vesting = db.query(TokenVestingDB).filter(\n        TokenVestingDB.id == vesting_id,\n        TokenVestingDB.user_id == user_id\n    ).first()\n    \n    if not vesting:\n        raise HTTPException(status_code=404, detail="Vesting not found")\n    \n    if not vesting.next_unlock_date or datetime.utcnow() < vesting.next_unlock_date:\n        raise HTTPException(status_code=400, detail="Tokens not yet unlocked")\n    \n    # Claim tokens\n    vesting.claimed_tokens += vesting.next_unlock_amount\n    \n    # Update next unlock (example: 25% every 30 days)\n    remaining = vesting.total_tokens - vesting.claimed_tokens\n    if remaining > 0:\n        vesting.next_unlock_date = vesting.next_unlock_date + timedelta(days=30)\n        vesting.next_unlock_amount = min(remaining, vesting.total_tokens * 0.25)\n    else:\n        vesting.next_unlock_date = None\n        vesting.next_unlock_amount = 0\n    \n    db.commit()\n    \n    return {\n        "message": "Tokens claimed successfully",\n        "amount": vesting.next_unlock_amount,\n        "remaining": remaining\n    }\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "launchpad"}\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8004)\n</create-file>\n</function_calls>'}