{'role': 'user', 'content': '<tool_result> <execute-command> ToolResult(success=True, output=\'{\\n  "output": "   #include <iostream>\\\\n   #include <memory>\\\\n   #include <thread>\\\\n   #include <vector>\\\\n   #include <queue>\\\\n   #include <map>\\\\n   #include <mutex>\\\\n   #include <condition_variable>\\\\n   #include <atomic>\\\\n   #include <chrono>\\\\n   #include <algorithm>\\\\n   #include <unordered_map>\\\\n   #include <websocketpp/config/asio_no_tls.hpp>\\\\n   #include <websocketpp/server.hpp>\\\\n   #include <nlohmann/json.hpp>\\\\n   \\\\n   using json = nlohmann::json;\\\\n   using namespace std::chrono;\\\\n   \\\\n   // Order types and structures\\\\n   enum class OrderType {\\\\n       MARKET,\\\\n       LIMIT,\\\\n       STOP_LOSS,\\\\n       STOP_LIMIT,\\\\n       TAKE_PROFIT,\\\\n       TAKE_PROFIT_LIMIT,\\\\n       TRAILING_STOP,\\\\n       ICEBERG,\\\\n       OCO,  // One-Cancels-Other\\\\n       BRACKET\\\\n   };\\\\n   \\\\n   enum class OrderSide {\\\\n       BUY,\\\\n       SELL\\\\n   };\\\\n   \\\\n   enum class OrderStatus {\\\\n       NEW,\\\\n       PARTIALLY_FILLED,\\\\n       FILLED,\\\\n       CANCELED,\\\\n       REJECTED,\\\\n       EXPIRED\\\\n   };\\\\n   \\\\n   enum class TimeInForce {\\\\n       GTC,  // Good Till Canceled\\\\n       IOC,  // Immediate or Cancel\\\\n       FOK,  // Fill or Kill\\\\n       GTD   // Good Till Date\\\\n   };\\\\n   \\\\n   struct Order {\\\\n       uint64_t id;\\\\n       std::string symbol;\\\\n       OrderSide side;\\\\n       OrderType type;\\\\n       TimeInForce timeInForce;\\\\n       double quantity;\\\\n       double price;\\\\n       double stopPrice;\\\\n       double filledQuantity;\\\\n       OrderStatus status;\\\\n       uint64_t timestamp;\\\\n       std::string clientOrderId;\\\\n       uint64_t userId;\\\\n       double icebergQty;\\\\n       uint64_t expireTime;\\\\n       \\\\n       Order(uint64_t id, const std::string& symbol, OrderSide side, OrderType type,\\\\n             double quantity, double price = 0.0, TimeInForce tif = TimeInForce::GTC)\\\\n           : id(id), symbol(symbol), side(side), type(type), timeInForce(tif),\\\\n             quantity(quantity), price(price), stopPrice(0.0), filledQuantity(0.0),\\\\n             status(OrderStatus::NEW), timestamp(duration_cast<milliseconds>(\\\\n                 system_clock::now().time_since_epoch()).count()),\\\\n             userId(0), icebergQty(0.0), expireTime(0) {}\\\\n   };\\\\n   \\\\n   struct Trade {\\\\n       uint64_t id;\\\\n       std::string symbol;\\\\n       uint64_t buyOrderId;\\\\n       uint64_t sellOrderId;\\\\n       uint64_t buyerId;\\\\n       uint64_t sellerId;\\\\n       double price;\\\\n       double quantity;\\\\n       uint64_t timestamp;\\\\n       double fee;\\\\n       std::string feeAsset;\\\\n   };\\\\n   \\\\n   // Advanced order book with multiple price levels\\\\n   class OrderBook {\\\\n   private:\\\\n       std::map<double, std::queue<std::shared_ptr<Order>>, std::greater<double>> bids;\\\\n       std::map<double, std::queue<std::shared_ptr<Order>>, std::less<double>> asks;\\\\n       std::mutex bookMutex;\\\\n       std::string symbol;\\\\n       \\\\n   public:\\\\n       OrderBook(const std::string& symbol) : symbol(symbol) {}\\\\n       \\\\n       void addOrder(std::shared_ptr<Order> order) {\\\\n           std::lock_guard<std::mutex> lock(bookMutex);\\\\n           \\\\n           if (order->side == OrderSide::BUY) {\\\\n               bids[order->price].push(order);\\\\n           } else {\\\\n               asks[order->price].push(order);\\\\n           }\\\\n       }\\\\n       \\\\n       void removeOrder(uint64_t orderId) {\\\\n           std::lock_guard<std::mutex> lock(bookMutex);\\\\n           // Implementation for order removal\\\\n       }\\\\n       \\\\n       std::vector<Trade> matchOrders() {\\\\n           std::lock_guard<std::mutex> lock(bookMutex);\\\\n           std::vector<Trade> trades;\\\\n           \\\\n           while (!bids.empty() && !asks.empty()) {\\\\n               auto& topBid = bids.rbegin()->second.front();\\\\n               auto& topAsk = asks.begin()->second.front();\\\\n               \\\\n               if (topBid->price >= topAsk->price) {\\\\n                   double tradePrice = topAsk->price;\\\\n                   double tradeQuantity = std::min(\\\\n                       topBid->quantity - topBid->filledQuantity,\\\\n                       topAsk->quantity - topAsk->filledQuantity\\\\n                   );\\\\n                   \\\\n                   Trade trade;\\\\n                   trade.id = generateTradeId();\\\\n                   trade.symbol = symbol;\\\\n                   trade.buyOrderId = topBid->id;\\\\n                   trade.sellOrderId = topAsk->id;\\\\n                   trade.buyerId = topBid->userId;\\\\n                   trade.sellerId = topAsk->userId;\\\\n                   trade.price = tradePrice;\\\\n                   trade.quantity = tradeQuantity;\\\\n                   trade.timestamp = duration_cast<milliseconds>(\\\\n                       system_clock::now().time_since_epoch()).count();\\\\n                   trade.fee = tradeQuantity * tradePrice * 0.001; // 0.1% fee\\\\n                   trade.feeAsset = \\\\"USDT\\\\";\\\\n                   \\\\n                   trades.push_back(trade);\\\\n",\\n  "exit_code": 0,\\n  "cwd": "/workspace/tigerex/backend/matching-engine"\\n}\') </execute-command> </tool_result>'}