{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/trading-bots-service/main.py">\nfrom fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime, timedelta\nimport asyncio\nimport json\nfrom enum import Enum\nimport uuid\nimport logging\nfrom sqlalchemy import create_engine, Column, String, Float, Integer, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport redis\nfrom collections import defaultdict\nimport numpy as np\nimport random\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title="Trading Bots Service", version="2.0.0")\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Database setup\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/trading_bots"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Redis setup for real-time data\nredis_client = redis.Redis(host=\'localhost\', port=6379, db=0, decode_responses=True)\n\n# WebSocket connection manager\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: Dict[str, WebSocket] = {}\n\n    async def connect(self, websocket: WebSocket, bot_id: str):\n        await websocket.accept()\n        self.active_connections[bot_id] = websocket\n        logger.info(f"WebSocket connected for bot {bot_id}")\n\n    def disconnect(self, bot_id: str):\n        if bot_id in self.active_connections:\n            del self.active_connections[bot_id]\n            logger.info(f"WebSocket disconnected for bot {bot_id}")\n\n    async def send_update(self, bot_id: str, message: dict):\n        if bot_id in self.active_connections:\n            try:\n                await self.active_connections[bot_id].send_json(message)\n            except Exception as e:\n                logger.error(f"Error sending update to bot {bot_id}: {e}")\n                self.disconnect(bot_id)\n\n    async def broadcast(self, message: dict):\n        for bot_id, connection in self.active_connections.items():\n            try:\n                await connection.send_json(message)\n            except Exception as e:\n                logger.error(f"Error broadcasting to bot {bot_id}: {e}")\n\nmanager = ConnectionManager()\n\n# Database Models\nclass BotDB(Base):\n    __tablename__ = "bots"\n    \n    id = Column(String, primary_key=True)\n    user_id = Column(String, nullable=False, index=True)\n    name = Column(String, nullable=False)\n    bot_type = Column(String, nullable=False)\n    trading_pair = Column(String, nullable=False)\n    status = Column(String, default="stopped")\n    config = Column(JSON, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    started_at = Column(DateTime, nullable=True)\n    stopped_at = Column(DateTime, nullable=True)\n\nclass BotPerformanceDB(Base):\n    __tablename__ = "bot_performance"\n    \n    id = Column(String, primary_key=True)\n    bot_id = Column(String, nullable=False, index=True)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    total_trades = Column(Integer, default=0)\n    winning_trades = Column(Integer, default=0)\n    losing_trades = Column(Integer, default=0)\n    total_profit = Column(Float, default=0.0)\n    total_loss = Column(Float, default=0.0)\n    roi = Column(Float, default=0.0)\n    sharpe_ratio = Column(Float, default=0.0)\n    max_drawdown = Column(Float, default=0.0)\n    win_rate = Column(Float, default=0.0)\n\nclass BotTradeDB(Base):\n    __tablename__ = "bot_trades"\n    \n    id = Column(String, primary_key=True)\n    bot_id = Column(String, nullable=False, index=True)\n    trade_type = Column(String, nullable=False)\n    price = Column(Float, nullable=False)\n    amount = Column(Float, nullable=False)\n    total = Column(Float, nullable=False)\n    profit_loss = Column(Float, default=0.0)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    status = Column(String, default="completed")\n\nclass BotRiskMetricsDB(Base):\n    __tablename__ = "bot_risk_metrics"\n    \n    id = Column(String, primary_key=True)\n    bot_id = Column(String, nullable=False, index=True)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    position_size = Column(Float, default=0.0)\n    leverage = Column(Float, default=1.0)\n    stop_loss = Column(Float, nullable=True)\n    take_profit = Column(Float, nullable=True)\n    risk_score = Column(Float, default=0.0)\n    exposure = Column(Float, default=0.0)\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Enums\nclass BotType(str, Enum):\n    GRID = "grid"\n    DCA = "dca"\n    MARTINGALE = "martingale"\n    ARBITRAGE = "arbitrage"\n    MARKET_MAKING = "market_making"\n\nclass BotStatus(str, Enum):\n    RUNNING = "running"\n    STOPPED = "stopped"\n    PAUSED = "paused"\n    ERROR = "error"\n\n# Pydantic Models\nclass BotCreate(BaseModel):\n    name: str\n    bot_type: BotType\n    trading_pair: str\n    config: Dict[str, Any]\n\nclass BotResponse(BaseModel):\n    id: str\n    user_id: str\n    name: str\n    bot_type: str\n    trading_pair: str\n    status: str\n    config: Dict[str, Any]\n    created_at: datetime\n    updated_at: datetime\n    started_at: Optional[datetime] = None\n    stopped_at: Optional[datetime] = None\n\nclass PerformanceMetrics(BaseModel):\n    total_trades: int\n    winning_trades: int\n    losing_trades: int\n    total_profit: float\n    total_loss: float\n    net_profit: float\n    roi: float\n    win_rate: float\n    sharpe_ratio: float\n    max_drawdown: float\n\n# Bot Execution Logic\nclass TradingBot:\n    def __init__(self, bot_id: str, user_id: str, bot_type: str, trading_pair: str, config: Dict, db: Session):\n        self.bot_id = bot_id\n        self.user_id = user_id\n        self.bot_type = bot_type\n        self.trading_pair = trading_pair\n        self.config = config\n        self.db = db\n        self.is_running = False\n        self.performance_data = {\n            "total_trades": 0,\n            "winning_trades": 0,\n            "losing_trades": 0,\n            "total_profit": 0.0,\n            "total_loss": 0.0\n        }\n\n    async def start(self):\n        self.is_running = True\n        logger.info(f"Starting bot {self.bot_id} of type {self.bot_type}")\n        \n        bot = self.db.query(BotDB).filter(BotDB.id == self.bot_id).first()\n        if bot:\n            bot.status = "running"\n            bot.started_at = datetime.utcnow()\n            self.db.commit()\n        \n        if self.bot_type == "grid":\n            await self.run_grid_bot()\n        elif self.bot_type == "dca":\n            await self.run_dca_bot()\n        elif self.bot_type == "martingale":\n            await self.run_martingale_bot()\n        elif self.bot_type == "arbitrage":\n            await self.run_arbitrage_bot()\n        elif self.bot_type == "market_making":\n            await self.run_market_making_bot()\n\n    async def stop(self):\n        self.is_running = False\n        logger.info(f"Stopping bot {self.bot_id}")\n        \n        bot = self.db.query(BotDB).filter(BotDB.id == self.bot_id).first()\n        if bot:\n            bot.status = "stopped"\n            bot.stopped_at = datetime.utcnow()\n            self.db.commit()\n\n    async def run_grid_bot(self):\n        grid_levels = self.config.get("grid_levels", 10)\n        price_low = self.config.get("price_range_low", 30000)\n        price_high = self.config.get("price_range_high", 50000)\n        \n        while self.is_running:\n            try:\n                current_price = random.uniform(price_low, price_high)\n                await manager.send_update(self.bot_id, {\n                    "type": "grid_update",\n                    "current_price": current_price,\n                    "performance": self.performance_data\n                })\n                await asyncio.sleep(10)\n            except Exception as e:\n                logger.error(f"Error in grid bot: {e}")\n                await asyncio.sleep(5)\n\n    async def run_dca_bot(self):\n        while self.is_running:\n            await asyncio.sleep(10)\n\n    async def run_martingale_bot(self):\n        while self.is_running:\n            await asyncio.sleep(10)\n\n    async def run_arbitrage_bot(self):\n        while self.is_running:\n            await asyncio.sleep(10)\n\n    async def run_market_making_bot(self):\n        while self.is_running:\n            await asyncio.sleep(10)\n\nactive_bots: Dict[str, TradingBot] = {}\n\n# API Endpoints\n@app.post("/bots", response_model=BotResponse)\nasync def create_bot(bot: BotCreate, user_id: str = "user123", db: Session = Depends(get_db)):\n    bot_id = str(uuid.uuid4())\n    db_bot = BotDB(\n        id=bot_id,\n        user_id=user_id,\n        name=bot.name,\n        bot_type=bot.bot_type,\n        trading_pair=bot.trading_pair,\n        status="stopped",\n        config=bot.config,\n        created_at=datetime.utcnow(),\n        updated_at=datetime.utcnow()\n    )\n    db.add(db_bot)\n    db.commit()\n    db.refresh(db_bot)\n    \n    return BotResponse(\n        id=db_bot.id,\n        user_id=db_bot.user_id,\n        name=db_bot.name,\n        bot_type=db_bot.bot_type,\n        trading_pair=db_bot.trading_pair,\n        status=db_bot.status,\n        config=db_bot.config,\n        created_at=db_bot.created_at,\n        updated_at=db_bot.updated_at\n    )\n\n@app.get("/bots", response_model=List[BotResponse])\nasync def list_bots(user_id: str = "user123", db: Session = Depends(get_db)):\n    bots = db.query(BotDB).filter(BotDB.user_id == user_id).all()\n    return [BotResponse(\n        id=bot.id,\n        user_id=bot.user_id,\n        name=bot.name,\n        bot_type=bot.bot_type,\n        trading_pair=bot.trading_pair,\n        status=bot.status,\n        config=bot.config,\n        created_at=bot.created_at,\n        updated_at=bot.updated_at\n    ) for bot in bots]\n\n@app.post("/bots/{bot_id}/start")\nasync def start_bot(bot_id: str, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):\n    bot = db.query(BotDB).filter(BotDB.id == bot_id).first()\n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    trading_bot = TradingBot(bot.id, bot.user_id, bot.bot_type, bot.trading_pair, bot.config, db)\n    active_bots[bot_id] = trading_bot\n    background_tasks.add_task(trading_bot.start)\n    \n    return {"message": "Bot started", "bot_id": bot_id}\n\n@app.post("/bots/{bot_id}/stop")\nasync def stop_bot(bot_id: str):\n    if bot_id not in active_bots:\n        raise HTTPException(status_code=400, detail="Bot not running")\n    await active_bots[bot_id].stop()\n    del active_bots[bot_id]\n    return {"message": "Bot stopped", "bot_id": bot_id}\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "active_bots": len(active_bots)}\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8001)\n</create-file>\n</function_calls>'}