{'role': 'assistant', 'content': 'Now let me start implementing the critical missing features. I\'ll begin with the admin panels for services that don\'t have them:\n\n<function_calls>\n<create-file file_path="backend/etf-trading-admin/src/main.py">\n"""\nTigerEx ETF Trading Admin Panel Service\nComprehensive admin panel for managing ETF products, rebalancing, and monitoring\n"""\n\nimport asyncio\nimport json\nimport logging\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom typing import Dict, List, Optional\nfrom enum import Enum\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, validator\nfrom sqlalchemy import create_engine, Column, String, DECIMAL, DateTime, Boolean, Integer, Text, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport redis\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(\n    title="TigerEx ETF Trading Admin Panel",\n    description="Admin panel for ETF product management and monitoring",\n    version="1.0.0"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Database setup\nDATABASE_URL = "postgresql://postgres:password@localhost/tigerex_etf_admin"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Redis setup\nredis_client = redis.Redis(host=\'localhost\', port=6379, db=0, decode_responses=True)\n\n# Enums\nclass ETFStatus(str, Enum):\n    ACTIVE = "active"\n    SUSPENDED = "suspended"\n    DELISTED = "delisted"\n    PENDING = "pending"\n\nclass RebalanceStatus(str, Enum):\n    SCHEDULED = "scheduled"\n    IN_PROGRESS = "in_progress"\n    COMPLETED = "completed"\n    FAILED = "failed"\n\n# Database Models\nclass ETFProductDB(Base):\n    __tablename__ = "etf_products"\n    \n    id = Column(String, primary_key=True)\n    symbol = Column(String, unique=True, nullable=False)\n    name = Column(String, nullable=False)\n    description = Column(Text)\n    leverage = Column(DECIMAL(10, 2), default=1.0)\n    management_fee = Column(DECIMAL(10, 4), default=0.0)\n    creation_fee = Column(DECIMAL(10, 4), default=0.0)\n    redemption_fee = Column(DECIMAL(10, 4), default=0.0)\n    min_creation_amount = Column(DECIMAL(20, 8), default=0.0)\n    min_redemption_amount = Column(DECIMAL(20, 8), default=0.0)\n    total_supply = Column(DECIMAL(30, 8), default=0.0)\n    nav = Column(DECIMAL(20, 8), default=0.0)  # Net Asset Value\n    status = Column(String, default="active")\n    underlying_assets = Column(JSON)  # List of assets and weights\n    rebalance_frequency = Column(String, default="daily")  # daily, weekly, monthly\n    last_rebalance = Column(DateTime)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass RebalanceHistoryDB(Base):\n    __tablename__ = "rebalance_history"\n    \n    id = Column(String, primary_key=True)\n    etf_id = Column(String, nullable=False)\n    rebalance_date = Column(DateTime, default=datetime.utcnow)\n    old_composition = Column(JSON)\n    new_composition = Column(JSON)\n    trades_executed = Column(JSON)\n    status = Column(String, default="scheduled")\n    error_message = Column(Text)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass ETFSubscriptionDB(Base):\n    __tablename__ = "etf_subscriptions"\n    \n    id = Column(String, primary_key=True)\n    user_id = Column(String, nullable=False)\n    etf_id = Column(String, nullable=False)\n    subscription_type = Column(String, nullable=False)  # creation, redemption\n    amount = Column(DECIMAL(20, 8), nullable=False)\n    nav_price = Column(DECIMAL(20, 8), nullable=False)\n    fee = Column(DECIMAL(20, 8), default=0.0)\n    status = Column(String, default="pending")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime)\n\nclass ETFPerformanceDB(Base):\n    __tablename__ = "etf_performance"\n    \n    id = Column(String, primary_key=True)\n    etf_id = Column(String, nullable=False)\n    date = Column(DateTime, default=datetime.utcnow)\n    nav = Column(DECIMAL(20, 8), nullable=False)\n    total_supply = Column(DECIMAL(30, 8), nullable=False)\n    daily_return = Column(DECIMAL(10, 4))\n    volume_24h = Column(DECIMAL(30, 8), default=0.0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Pydantic Models\nclass ETFProductCreate(BaseModel):\n    symbol: str\n    name: str\n    description: Optional[str]\n    leverage: Decimal = Decimal("1.0")\n    management_fee: Decimal = Decimal("0.0")\n    creation_fee: Decimal = Decimal("0.0")\n    redemption_fee: Decimal = Decimal("0.0")\n    min_creation_amount: Decimal = Decimal("0.0")\n    min_redemption_amount: Decimal = Decimal("0.0")\n    underlying_assets: List[Dict]\n    rebalance_frequency: str = "daily"\n\nclass ETFProductUpdate(BaseModel):\n    name: Optional[str]\n    description: Optional[str]\n    management_fee: Optional[Decimal]\n    creation_fee: Optional[Decimal]\n    redemption_fee: Optional[Decimal]\n    status: Optional[ETFStatus]\n    rebalance_frequency: Optional[str]\n\nclass ETFProductResponse(BaseModel):\n    id: str\n    symbol: str\n    name: str\n    description: Optional[str]\n    leverage: Decimal\n    management_fee: Decimal\n    creation_fee: Decimal\n    redemption_fee: Decimal\n    total_supply: Decimal\n    nav: Decimal\n    status: str\n    underlying_assets: List[Dict]\n    rebalance_frequency: str\n    last_rebalance: Optional[datetime]\n    created_at: datetime\n\nclass RebalanceRequest(BaseModel):\n    etf_id: str\n    new_composition: List[Dict]\n    reason: Optional[str]\n\nclass ETFStatistics(BaseModel):\n    total_etfs: int\n    active_etfs: int\n    total_aum: Decimal  # Assets Under Management\n    total_volume_24h: Decimal\n    pending_rebalances: int\n    pending_subscriptions: int\n\n# API Endpoints\n\n@app.post("/admin/etf/products", response_model=ETFProductResponse)\nasync def create_etf_product(product: ETFProductCreate, db: Session = Depends(get_db)):\n    """Create a new ETF product"""\n    import uuid\n    \n    # Check if symbol already exists\n    existing = db.query(ETFProductDB).filter(ETFProductDB.symbol == product.symbol).first()\n    if existing:\n        raise HTTPException(status_code=400, detail="ETF symbol already exists")\n    \n    # Validate underlying assets weights sum to 100%\n    total_weight = sum(asset.get(\'weight\', 0) for asset in product.underlying_assets)\n    if abs(total_weight - 100.0) > 0.01:\n        raise HTTPException(status_code=400, detail="Asset weights must sum to 100%")\n    \n    etf_id = str(uuid.uuid4())\n    db_etf = ETFProductDB(\n        id=etf_id,\n        symbol=product.symbol,\n        name=product.name,\n        description=product.description,\n        leverage=product.leverage,\n        management_fee=product.management_fee,\n        creation_fee=product.creation_fee,\n        redemption_fee=product.redemption_fee,\n        min_creation_amount=product.min_creation_amount,\n        min_redemption_amount=product.min_redemption_amount,\n        underlying_assets=product.underlying_assets,\n        rebalance_frequency=product.rebalance_frequency,\n        status="pending",\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(db_etf)\n    db.commit()\n    db.refresh(db_etf)\n    \n    logger.info(f"Created ETF product: {product.symbol}")\n    \n    return ETFProductResponse(\n        id=db_etf.id,\n        symbol=db_etf.symbol,\n        name=db_etf.name,\n        description=db_etf.description,\n        leverage=db_etf.leverage,\n        management_fee=db_etf.management_fee,\n        creation_fee=db_etf.creation_fee,\n        redemption_fee=db_etf.redemption_fee,\n        total_supply=db_etf.total_supply,\n        nav=db_etf.nav,\n        status=db_etf.status,\n        underlying_assets=db_etf.underlying_assets,\n        rebalance_frequency=db_etf.rebalance_frequency,\n        last_rebalance=db_etf.last_rebalance,\n        created_at=db_etf.created_at\n    )\n\n@app.get("/admin/etf/products", response_model=List[ETFProductResponse])\nasync def list_etf_products(\n    status: Optional[str] = None,\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db)\n):\n    """List all ETF products"""\n    query = db.query(ETFProductDB)\n    \n    if status:\n        query = query.filter(ETFProductDB.status == status)\n    \n    etfs = query.offset(skip).limit(limit).all()\n    \n    return [ETFProductResponse(\n        id=etf.id,\n        symbol=etf.symbol,\n        name=etf.name,\n        description=etf.description,\n        leverage=etf.leverage,\n        management_fee=etf.management_fee,\n        creation_fee=etf.creation_fee,\n        redemption_fee=etf.redemption_fee,\n        total_supply=etf.total_supply,\n        nav=etf.nav,\n        status=etf.status,\n        underlying_assets=etf.underlying_assets,\n        rebalance_frequency=etf.rebalance_frequency,\n        last_rebalance=etf.last_rebalance,\n        created_at=etf.created_at\n    ) for etf in etfs]\n\n@app.get("/admin/etf/products/{etf_id}", response_model=ETFProductResponse)\nasync def get_etf_product(etf_id: str, db: Session = Depends(get_db)):\n    """Get ETF product details"""\n    etf = db.query(ETFProductDB).filter(ETFProductDB.id == etf_id).first()\n    if not etf:\n        raise HTTPException(status_code=404, detail="ETF not found")\n    \n    return ETFProductResponse(\n        id=etf.id,\n        symbol=etf.symbol,\n        name=etf.name,\n        description=etf.description,\n        leverage=etf.leverage,\n        management_fee=etf.management_fee,\n        creation_fee=etf.creation_fee,\n        redemption_fee=etf.redemption_fee,\n        total_supply=etf.total_supply,\n        nav=etf.nav,\n        status=etf.status,\n        underlying_assets=etf.underlying_assets,\n        rebalance_frequency=etf.rebalance_frequency,\n        last_rebalance=etf.last_rebalance,\n        created_at=etf.created_at\n    )\n\n@app.put("/admin/etf/products/{etf_id}", response_model=ETFProductResponse)\nasync def update_etf_product(\n    etf_id: str,\n    update: ETFProductUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update ETF product"""\n    etf = db.query(ETFProductDB).filter(ETFProductDB.id == etf_id).first()\n    if not etf:\n        raise HTTPException(status_code=404, detail="ETF not found")\n    \n    if update.name:\n        etf.name = update.name\n    if update.description:\n        etf.description = update.description\n    if update.management_fee:\n        etf.management_fee = update.management_fee\n    if update.creation_fee:\n        etf.creation_fee = update.creation_fee\n    if update.redemption_fee:\n        etf.redemption_fee = update.redemption_fee\n    if update.status:\n        etf.status = update.status\n    if update.rebalance_frequency:\n        etf.rebalance_frequency = update.rebalance_frequency\n    \n    etf.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(etf)\n    \n    logger.info(f"Updated ETF product: {etf.symbol}")\n    \n    return ETFProductResponse(\n        id=etf.id,\n        symbol=etf.symbol,\n        name=etf.name,\n        description=etf.description,\n        leverage=etf.leverage,\n        management_fee=etf.management_fee,\n        creation_fee=etf.creation_fee,\n        redemption_fee=etf.redemption_fee,\n        total_supply=etf.total_supply,\n        nav=etf.nav,\n        status=etf.status,\n        underlying_assets=etf.underlying_assets,\n        rebalance_frequency=etf.rebalance_frequency,\n        last_rebalance=etf.last_rebalance,\n        created_at=etf.created_at\n    )\n\n@app.post("/admin/etf/rebalance")\nasync def trigger_rebalance(\n    request: RebalanceRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db)\n):\n    """Trigger ETF rebalancing"""\n    import uuid\n    \n    etf = db.query(ETFProductDB).filter(ETFProductDB.id == request.etf_id).first()\n    if not etf:\n        raise HTTPException(status_code=404, detail="ETF not found")\n    \n    # Create rebalance record\n    rebalance_id = str(uuid.uuid4())\n    rebalance = RebalanceHistoryDB(\n        id=rebalance_id,\n        etf_id=request.etf_id,\n        old_composition=etf.underlying_assets,\n        new_composition=request.new_composition,\n        status="scheduled",\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(rebalance)\n    db.commit()\n    \n    # Schedule rebalancing in background\n    background_tasks.add_task(execute_rebalance, rebalance_id, request.etf_id, request.new_composition)\n    \n    logger.info(f"Scheduled rebalance for ETF: {etf.symbol}")\n    \n    return {\n        "message": "Rebalance scheduled",\n        "rebalance_id": rebalance_id,\n        "etf_id": request.etf_id\n    }\n\nasync def execute_rebalance(rebalance_id: str, etf_id: str, new_composition: List[Dict]):\n    """Execute ETF rebalancing (background task)"""\n    db = SessionLocal()\n    try:\n        rebalance = db.query(RebalanceHistoryDB).filter(RebalanceHistoryDB.id == rebalance_id).first()\n        etf = db.query(ETFProductDB).filter(ETFProductDB.id == etf_id).first()\n        \n        if not rebalance or not etf:\n            return\n        \n        rebalance.status = "in_progress"\n        db.commit()\n        \n        # Simulate rebalancing logic\n        # In production, this would execute actual trades\n        await asyncio.sleep(5)\n        \n        # Update ETF composition\n        etf.underlying_assets = new_composition\n        etf.last_rebalance = datetime.utcnow()\n        \n        rebalance.status = "completed"\n        rebalance.trades_executed = [{"asset": "BTC", "amount": 1.0, "price": 45000}]  # Example\n        \n        db.commit()\n        \n        logger.info(f"Completed rebalance for ETF: {etf.symbol}")\n        \n    except Exception as e:\n        logger.error(f"Rebalance failed: {str(e)}")\n        rebalance.status = "failed"\n        rebalance.error_message = str(e)\n        db.commit()\n    finally:\n        db.close()\n\n@app.get("/admin/etf/statistics", response_model=ETFStatistics)\nasync def get_etf_statistics(db: Session = Depends(get_db)):\n    """Get ETF platform statistics"""\n    total_etfs = db.query(ETFProductDB).count()\n    active_etfs = db.query(ETFProductDB).filter(ETFProductDB.status == "active").count()\n    \n    # Calculate total AUM\n    etfs = db.query(ETFProductDB).filter(ETFProductDB.status == "active").all()\n    total_aum = sum(etf.total_supply * etf.nav for etf in etfs)\n    \n    # Calculate 24h volume\n    yesterday = datetime.utcnow() - timedelta(days=1)\n    performance_records = db.query(ETFPerformanceDB).filter(\n        ETFPerformanceDB.date >= yesterday\n    ).all()\n    total_volume_24h = sum(record.volume_24h for record in performance_records)\n    \n    # Count pending items\n    pending_rebalances = db.query(RebalanceHistoryDB).filter(\n        RebalanceHistoryDB.status.in_(["scheduled", "in_progress"])\n    ).count()\n    \n    pending_subscriptions = db.query(ETFSubscriptionDB).filter(\n        ETFSubscriptionDB.status == "pending"\n    ).count()\n    \n    return ETFStatistics(\n        total_etfs=total_etfs,\n        active_etfs=active_etfs,\n        total_aum=Decimal(str(total_aum)),\n        total_volume_24h=Decimal(str(total_volume_24h)),\n        pending_rebalances=pending_rebalances,\n        pending_subscriptions=pending_subscriptions\n    )\n\n@app.get("/admin/etf/subscriptions")\nasync def list_subscriptions(\n    status: Optional[str] = None,\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db)\n):\n    """List ETF subscriptions"""\n    query = db.query(ETFSubscriptionDB)\n    \n    if status:\n        query = query.filter(ETFSubscriptionDB.status == status)\n    \n    subscriptions = query.order_by(ETFSubscriptionDB.created_at.desc()).offset(skip).limit(limit).all()\n    \n    return [{\n        "id": sub.id,\n        "user_id": sub.user_id,\n        "etf_id": sub.etf_id,\n        "subscription_type": sub.subscription_type,\n        "amount": float(sub.amount),\n        "nav_price": float(sub.nav_price),\n        "fee": float(sub.fee),\n        "status": sub.status,\n        "created_at": sub.created_at.isoformat(),\n        "completed_at": sub.completed_at.isoformat() if sub.completed_at else None\n    } for sub in subscriptions]\n\n@app.get("/admin/etf/performance/{etf_id}")\nasync def get_etf_performance(\n    etf_id: str,\n    days: int = 30,\n    db: Session = Depends(get_db)\n):\n    """Get ETF performance history"""\n    start_date = datetime.utcnow() - timedelta(days=days)\n    \n    performance = db.query(ETFPerformanceDB).filter(\n        ETFPerformanceDB.etf_id == etf_id,\n        ETFPerformanceDB.date >= start_date\n    ).order_by(ETFPerformanceDB.date).all()\n    \n    return [{\n        "date": perf.date.isoformat(),\n        "nav": float(perf.nav),\n        "total_supply": float(perf.total_supply),\n        "daily_return": float(perf.daily_return) if perf.daily_return else None,\n        "volume_24h": float(perf.volume_24h)\n    } for perf in performance]\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "etf-trading-admin"}\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8113)\n</create-file>\n</function_calls>'}