{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/payment-gateway-service/src/main.py">\n"""\nTigerEx Payment Gateway Service\nComprehensive payment integration with multiple providers\nPort: 8123\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\nimport hashlib\nimport hmac\nimport json\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_payment_gateway"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass PaymentProvider(str, Enum):\n    # Card Processors\n    STRIPE = "stripe"\n    ADYEN = "adyen"\n    SQUARE = "square"\n    BRAINTREE = "braintree"\n    \n    # Digital Wallets\n    APPLE_PAY = "apple_pay"\n    GOOGLE_PAY = "google_pay"\n    SAMSUNG_PAY = "samsung_pay"\n    PAYPAL = "paypal"\n    \n    # Bank Transfers\n    PLAID = "plaid"\n    WISE = "wise"\n    RAZORPAY = "razorpay"\n    \n    # Buy Now Pay Later\n    KLARNA = "klarna"\n    AFTERPAY = "afterpay"\n    AFFIRM = "affirm"\n\nclass TransactionStatus(str, Enum):\n    PENDING = "pending"\n    PROCESSING = "processing"\n    COMPLETED = "completed"\n    FAILED = "failed"\n    REFUNDED = "refunded"\n    CANCELLED = "cancelled"\n\nclass TransactionType(str, Enum):\n    DEPOSIT = "deposit"\n    WITHDRAWAL = "withdrawal"\n    REFUND = "refund"\n\n# Database Models\nclass PaymentTransaction(Base):\n    __tablename__ = "payment_transactions"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    transaction_id = Column(String, unique=True, index=True)\n    user_id = Column(Integer, index=True)\n    provider = Column(String, index=True)\n    transaction_type = Column(String)\n    \n    # Amounts\n    amount = Column(Float)\n    currency = Column(String)\n    fee = Column(Float, default=0.0)\n    net_amount = Column(Float)\n    \n    # Payment details\n    payment_method = Column(String)\n    payment_method_details = Column(JSON)\n    \n    # Status\n    status = Column(String, default="pending")\n    error_message = Column(String, nullable=True)\n    \n    # External references\n    external_transaction_id = Column(String, nullable=True)\n    external_payment_id = Column(String, nullable=True)\n    \n    # Timestamps\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n    \n    # Additional data\n    metadata = Column(JSON)\n\nclass PaymentMethod(Base):\n    __tablename__ = "payment_methods"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, index=True)\n    provider = Column(String)\n    method_type = Column(String)  # card, bank_account, wallet\n    \n    # Card details (encrypted)\n    card_last4 = Column(String, nullable=True)\n    card_brand = Column(String, nullable=True)\n    card_exp_month = Column(Integer, nullable=True)\n    card_exp_year = Column(Integer, nullable=True)\n    \n    # Bank details (encrypted)\n    bank_name = Column(String, nullable=True)\n    account_last4 = Column(String, nullable=True)\n    \n    # Wallet details\n    wallet_email = Column(String, nullable=True)\n    \n    # External references\n    external_method_id = Column(String)\n    \n    # Status\n    is_default = Column(Boolean, default=False)\n    is_verified = Column(Boolean, default=False)\n    is_active = Column(Boolean, default=True)\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass ProviderConfig(Base):\n    __tablename__ = "provider_configs"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    provider = Column(String, unique=True, index=True)\n    is_enabled = Column(Boolean, default=True)\n    \n    # API Configuration\n    api_key = Column(String)\n    api_secret = Column(String)\n    webhook_secret = Column(String, nullable=True)\n    \n    # Limits\n    min_amount = Column(Float, default=10.0)\n    max_amount = Column(Float, default=50000.0)\n    daily_limit = Column(Float, default=100000.0)\n    \n    # Fees\n    fee_percentage = Column(Float, default=2.5)\n    fixed_fee = Column(Float, default=0.0)\n    \n    # Supported features\n    supports_deposits = Column(Boolean, default=True)\n    supports_withdrawals = Column(Boolean, default=True)\n    supports_refunds = Column(Boolean, default=True)\n    supports_recurring = Column(Boolean, default=False)\n    \n    # Supported currencies\n    supported_currencies = Column(JSON)\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    metadata = Column(JSON)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass DepositRequest(BaseModel):\n    user_id: int\n    provider: PaymentProvider\n    amount: float = Field(gt=0)\n    currency: str = Field(default="USD")\n    payment_method_id: Optional[str] = None\n    return_url: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass WithdrawalRequest(BaseModel):\n    user_id: int\n    provider: PaymentProvider\n    amount: float = Field(gt=0)\n    currency: str = Field(default="USD")\n    payment_method_id: str\n    metadata: Optional[Dict[str, Any]] = None\n\nclass RefundRequest(BaseModel):\n    transaction_id: str\n    amount: Optional[float] = None\n    reason: Optional[str] = None\n\nclass PaymentMethodCreate(BaseModel):\n    user_id: int\n    provider: PaymentProvider\n    method_type: str\n    card_token: Optional[str] = None\n    bank_token: Optional[str] = None\n    wallet_email: Optional[str] = None\n    is_default: bool = False\n    metadata: Optional[Dict[str, Any]] = None\n\n# FastAPI app\napp = FastAPI(\n    title="TigerEx Payment Gateway Service",\n    description="Comprehensive payment integration service",\n    version="1.0.0"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Helper functions\ndef generate_transaction_id() -> str:\n    """Generate unique transaction ID"""\n    import uuid\n    return f"TXN-{uuid.uuid4().hex[:16].upper()}"\n\ndef calculate_fee(amount: float, provider: str, db: Session) -> float:\n    """Calculate transaction fee"""\n    config = db.query(ProviderConfig).filter(ProviderConfig.provider == provider).first()\n    if not config:\n        return 0.0\n    \n    percentage_fee = amount * (config.fee_percentage / 100)\n    return percentage_fee + config.fixed_fee\n\n# ==================== DEPOSIT ENDPOINTS ====================\n\n@app.post("/api/deposits", status_code=201)\nasync def create_deposit(\n    deposit: DepositRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db)\n):\n    """Create a new deposit transaction"""\n    try:\n        # Validate provider is enabled\n        config = db.query(ProviderConfig).filter(\n            ProviderConfig.provider == deposit.provider,\n            ProviderConfig.is_enabled == True\n        ).first()\n        \n        if not config:\n            raise HTTPException(status_code=400, detail="Payment provider not available")\n        \n        # Validate amount\n        if deposit.amount < config.min_amount:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Minimum deposit amount is {config.min_amount} {deposit.currency}"\n            )\n        \n        if deposit.amount > config.max_amount:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Maximum deposit amount is {config.max_amount} {deposit.currency}"\n            )\n        \n        # Calculate fee\n        fee = calculate_fee(deposit.amount, deposit.provider, db)\n        net_amount = deposit.amount - fee\n        \n        # Create transaction\n        transaction = PaymentTransaction(\n            transaction_id=generate_transaction_id(),\n            user_id=deposit.user_id,\n            provider=deposit.provider,\n            transaction_type="deposit",\n            amount=deposit.amount,\n            currency=deposit.currency,\n            fee=fee,\n            net_amount=net_amount,\n            status="pending",\n            metadata=deposit.metadata or {}\n        )\n        \n        db.add(transaction)\n        db.commit()\n        db.refresh(transaction)\n        \n        # Process payment based on provider\n        # This would integrate with actual payment provider APIs\n        payment_url = None\n        if deposit.provider in [PaymentProvider.STRIPE, PaymentProvider.ADYEN]:\n            payment_url = f"https://checkout.{deposit.provider}.com/{transaction.transaction_id}"\n        \n        logger.info(f"Created deposit transaction: {transaction.transaction_id}")\n        \n        return {\n            "transaction_id": transaction.transaction_id,\n            "amount": transaction.amount,\n            "currency": transaction.currency,\n            "fee": transaction.fee,\n            "net_amount": transaction.net_amount,\n            "status": transaction.status,\n            "payment_url": payment_url,\n            "created_at": transaction.created_at\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating deposit: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/deposits/{transaction_id}")\nasync def get_deposit(transaction_id: str, db: Session = Depends(get_db)):\n    """Get deposit transaction details"""\n    transaction = db.query(PaymentTransaction).filter(\n        PaymentTransaction.transaction_id == transaction_id,\n        PaymentTransaction.transaction_type == "deposit"\n    ).first()\n    \n    if not transaction:\n        raise HTTPException(status_code=404, detail="Transaction not found")\n    \n    return transaction\n\n# ==================== WITHDRAWAL ENDPOINTS ====================\n\n@app.post("/api/withdrawals", status_code=201)\nasync def create_withdrawal(\n    withdrawal: WithdrawalRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db)\n):\n    """Create a new withdrawal transaction"""\n    try:\n        # Validate provider is enabled\n        config = db.query(ProviderConfig).filter(\n            ProviderConfig.provider == withdrawal.provider,\n            ProviderConfig.is_enabled == True\n        ).first()\n        \n        if not config:\n            raise HTTPException(status_code=400, detail="Payment provider not available")\n        \n        if not config.supports_withdrawals:\n            raise HTTPException(status_code=400, detail="Provider does not support withdrawals")\n        \n        # Validate payment method\n        payment_method = db.query(PaymentMethod).filter(\n            PaymentMethod.user_id == withdrawal.user_id,\n            PaymentMethod.external_method_id == withdrawal.payment_method_id,\n            PaymentMethod.is_active == True\n        ).first()\n        \n        if not payment_method:\n            raise HTTPException(status_code=404, detail="Payment method not found")\n        \n        # Calculate fee\n        fee = calculate_fee(withdrawal.amount, withdrawal.provider, db)\n        net_amount = withdrawal.amount - fee\n        \n        # Create transaction\n        transaction = PaymentTransaction(\n            transaction_id=generate_transaction_id(),\n            user_id=withdrawal.user_id,\n            provider=withdrawal.provider,\n            transaction_type="withdrawal",\n            amount=withdrawal.amount,\n            currency=withdrawal.currency,\n            fee=fee,\n            net_amount=net_amount,\n            status="pending",\n            payment_method=payment_method.method_type,\n            metadata=withdrawal.metadata or {}\n        )\n        \n        db.add(transaction)\n        db.commit()\n        db.refresh(transaction)\n        \n        logger.info(f"Created withdrawal transaction: {transaction.transaction_id}")\n        \n        return {\n            "transaction_id": transaction.transaction_id,\n            "amount": transaction.amount,\n            "currency": transaction.currency,\n            "fee": transaction.fee,\n            "net_amount": transaction.net_amount,\n            "status": transaction.status,\n            "created_at": transaction.created_at\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating withdrawal: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== REFUND ENDPOINTS ====================\n\n@app.post("/api/refunds", status_code=201)\nasync def create_refund(refund: RefundRequest, db: Session = Depends(get_db)):\n    """Create a refund for a transaction"""\n    try:\n        # Find original transaction\n        transaction = db.query(PaymentTransaction).filter(\n            PaymentTransaction.transaction_id == refund.transaction_id\n        ).first()\n        \n        if not transaction:\n            raise HTTPException(status_code=404, detail="Transaction not found")\n        \n        if transaction.status != "completed":\n            raise HTTPException(status_code=400, detail="Can only refund completed transactions")\n        \n        # Determine refund amount\n        refund_amount = refund.amount if refund.amount else transaction.amount\n        \n        if refund_amount > transaction.amount:\n            raise HTTPException(status_code=400, detail="Refund amount exceeds original amount")\n        \n        # Create refund transaction\n        refund_transaction = PaymentTransaction(\n            transaction_id=generate_transaction_id(),\n            user_id=transaction.user_id,\n            provider=transaction.provider,\n            transaction_type="refund",\n            amount=refund_amount,\n            currency=transaction.currency,\n            fee=0.0,\n            net_amount=refund_amount,\n            status="pending",\n            metadata={"original_transaction_id": transaction.transaction_id, "reason": refund.reason}\n        )\n        \n        db.add(refund_transaction)\n        \n        # Update original transaction\n        transaction.status = "refunded"\n        \n        db.commit()\n        db.refresh(refund_transaction)\n        \n        logger.info(f"Created refund transaction: {refund_transaction.transaction_id}")\n        \n        return refund_transaction\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating refund: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== PAYMENT METHOD ENDPOINTS ====================\n\n@app.post("/api/payment-methods", status_code=201)\nasync def add_payment_method(method: PaymentMethodCreate, db: Session = Depends(get_db)):\n    """Add a new payment method"""\n    try:\n        # If this is set as default, unset other defaults\n        if method.is_default:\n            db.query(PaymentMethod).filter(\n                PaymentMethod.user_id == method.user_id\n            ).update({"is_default": False})\n        \n        # Create payment method\n        payment_method = PaymentMethod(\n            user_id=method.user_id,\n            provider=method.provider,\n            method_type=method.method_type,\n            is_default=method.is_default,\n            external_method_id=f"pm_{generate_transaction_id()}",\n            metadata=method.metadata or {}\n        )\n        \n        # Set method-specific details\n        if method.method_type == "card" and method.card_token:\n            # In production, this would tokenize the card with the provider\n            payment_method.card_last4 = "4242"\n            payment_method.card_brand = "visa"\n            payment_method.card_exp_month = 12\n            payment_method.card_exp_year = 2025\n        elif method.method_type == "bank_account" and method.bank_token:\n            payment_method.bank_name = "Example Bank"\n            payment_method.account_last4 = "1234"\n        elif method.method_type == "wallet" and method.wallet_email:\n            payment_method.wallet_email = method.wallet_email\n        \n        db.add(payment_method)\n        db.commit()\n        db.refresh(payment_method)\n        \n        logger.info(f"Added payment method for user {method.user_id}")\n        \n        return payment_method\n        \n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error adding payment method: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/payment-methods/{user_id}")\nasync def get_payment_methods(user_id: int, db: Session = Depends(get_db)):\n    """Get all payment methods for a user"""\n    methods = db.query(PaymentMethod).filter(\n        PaymentMethod.user_id == user_id,\n        PaymentMethod.is_active == True\n    ).all()\n    \n    return methods\n\n@app.delete("/api/payment-methods/{method_id}")\nasync def delete_payment_method(method_id: int, db: Session = Depends(get_db)):\n    """Delete a payment method"""\n    try:\n        method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id).first()\n        if not method:\n            raise HTTPException(status_code=404, detail="Payment method not found")\n        \n        method.is_active = False\n        db.commit()\n        \n        logger.info(f"Deleted payment method: {method_id}")\n        \n        return {"message": "Payment method deleted successfully"}\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error deleting payment method: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== PROVIDER CONFIGURATION ====================\n\n@app.get("/api/providers")\nasync def get_providers(db: Session = Depends(get_db)):\n    """Get all available payment providers"""\n    providers = db.query(ProviderConfig).filter(ProviderConfig.is_enabled == True).all()\n    \n    # Return public information only\n    return [\n        {\n            "provider": p.provider,\n            "min_amount": p.min_amount,\n            "max_amount": p.max_amount,\n            "fee_percentage": p.fee_percentage,\n            "fixed_fee": p.fixed_fee,\n            "supports_deposits": p.supports_deposits,\n            "supports_withdrawals": p.supports_withdrawals,\n            "supports_refunds": p.supports_refunds,\n            "supported_currencies": p.supported_currencies\n        }\n        for p in providers\n    ]\n\n# ==================== WEBHOOKS ====================\n\n@app.post("/api/webhooks/{provider}")\nasync def handle_webhook(provider: str, request: Dict[str, Any], db: Session = Depends(get_db)):\n    """Handle webhook from payment provider"""\n    try:\n        # Verify webhook signature\n        # This would be provider-specific\n        \n        # Process webhook event\n        event_type = request.get("type") or request.get("event_type")\n        \n        if event_type in ["payment.succeeded", "charge.succeeded"]:\n            # Update transaction status\n            external_id = request.get("id")\n            transaction = db.query(PaymentTransaction).filter(\n                PaymentTransaction.external_transaction_id == external_id\n            ).first()\n            \n            if transaction:\n                transaction.status = "completed"\n                transaction.completed_at = datetime.utcnow()\n                db.commit()\n                \n                logger.info(f"Payment succeeded: {transaction.transaction_id}")\n        \n        elif event_type in ["payment.failed", "charge.failed"]:\n            external_id = request.get("id")\n            transaction = db.query(PaymentTransaction).filter(\n                PaymentTransaction.external_transaction_id == external_id\n            ).first()\n            \n            if transaction:\n                transaction.status = "failed"\n                transaction.error_message = request.get("error", {}).get("message")\n                db.commit()\n                \n                logger.info(f"Payment failed: {transaction.transaction_id}")\n        \n        return {"status": "success"}\n        \n    except Exception as e:\n        logger.error(f"Error processing webhook: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== ANALYTICS ====================\n\n@app.get("/api/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get payment analytics overview"""\n    try:\n        total_transactions = db.query(PaymentTransaction).count()\n        total_deposits = db.query(PaymentTransaction).filter(\n            PaymentTransaction.transaction_type == "deposit"\n        ).count()\n        total_withdrawals = db.query(PaymentTransaction).filter(\n            PaymentTransaction.transaction_type == "withdrawal"\n        ).count()\n        \n        total_volume = db.query(PaymentTransaction).filter(\n            PaymentTransaction.status == "completed"\n        ).with_entities(db.func.sum(PaymentTransaction.amount)).scalar() or 0.0\n        \n        total_fees = db.query(PaymentTransaction).filter(\n            PaymentTransaction.status == "completed"\n        ).with_entities(db.func.sum(PaymentTransaction.fee)).scalar() or 0.0\n        \n        success_rate = db.query(PaymentTransaction).filter(\n            PaymentTransaction.status == "completed"\n        ).count() / max(total_transactions, 1) * 100\n        \n        return {\n            "total_transactions": total_transactions,\n            "total_deposits": total_deposits,\n            "total_withdrawals": total_withdrawals,\n            "total_volume": total_volume,\n            "total_fees": total_fees,\n            "success_rate": success_rate\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Health check\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "payment-gateway"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8123)\n</create-file>\n</function_calls>'}