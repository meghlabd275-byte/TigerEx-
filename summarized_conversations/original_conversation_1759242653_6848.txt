{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/alpha-market-admin/src/main.py">\n"""\nTigerEx Alpha Market Admin Panel\nManages alpha trading strategies, signal providers, and performance tracking\nPort: 8115\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends, Query\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Database setup\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_alpha_market"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass StrategyType(str, Enum):\n    MOMENTUM = "momentum"\n    MEAN_REVERSION = "mean_reversion"\n    ARBITRAGE = "arbitrage"\n    MARKET_MAKING = "market_making"\n    TREND_FOLLOWING = "trend_following"\n    STATISTICAL_ARBITRAGE = "statistical_arbitrage"\n    PAIRS_TRADING = "pairs_trading"\n    SENTIMENT_ANALYSIS = "sentiment_analysis"\n\nclass SignalType(str, Enum):\n    BUY = "buy"\n    SELL = "sell"\n    HOLD = "hold"\n    STRONG_BUY = "strong_buy"\n    STRONG_SELL = "strong_sell"\n\nclass ProviderStatus(str, Enum):\n    ACTIVE = "active"\n    INACTIVE = "inactive"\n    SUSPENDED = "suspended"\n    UNDER_REVIEW = "under_review"\n\nclass SubscriptionTier(str, Enum):\n    FREE = "free"\n    BASIC = "basic"\n    PREMIUM = "premium"\n    ENTERPRISE = "enterprise"\n\n# Database Models\nclass AlphaStrategy(Base):\n    __tablename__ = "alpha_strategies"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    description = Column(Text)\n    strategy_type = Column(String)\n    provider_id = Column(Integer)\n    risk_level = Column(String)  # low, medium, high\n    min_investment = Column(Float)\n    performance_fee = Column(Float)\n    management_fee = Column(Float)\n    sharpe_ratio = Column(Float)\n    max_drawdown = Column(Float)\n    total_return = Column(Float)\n    win_rate = Column(Float)\n    avg_trade_duration = Column(Integer)  # in hours\n    total_trades = Column(Integer)\n    active_subscribers = Column(Integer, default=0)\n    aum = Column(Float, default=0.0)  # Assets Under Management\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass SignalProvider(Base):\n    __tablename__ = "signal_providers"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    email = Column(String, unique=True)\n    company = Column(String)\n    description = Column(Text)\n    status = Column(String, default="active")\n    verification_status = Column(String, default="pending")  # pending, verified, rejected\n    rating = Column(Float, default=0.0)\n    total_strategies = Column(Integer, default=0)\n    total_subscribers = Column(Integer, default=0)\n    total_aum = Column(Float, default=0.0)\n    success_rate = Column(Float, default=0.0)\n    avg_return = Column(Float, default=0.0)\n    joined_date = Column(DateTime, default=datetime.utcnow)\n    last_active = Column(DateTime, default=datetime.utcnow)\n    kyc_verified = Column(Boolean, default=False)\n    metadata = Column(JSON)\n\nclass TradingSignal(Base):\n    __tablename__ = "trading_signals"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    strategy_id = Column(Integer, index=True)\n    provider_id = Column(Integer, index=True)\n    symbol = Column(String, index=True)\n    signal_type = Column(String)\n    entry_price = Column(Float)\n    target_price = Column(Float)\n    stop_loss = Column(Float)\n    confidence = Column(Float)  # 0-100\n    timeframe = Column(String)  # 1h, 4h, 1d, etc.\n    reasoning = Column(Text)\n    status = Column(String, default="active")  # active, executed, expired, cancelled\n    created_at = Column(DateTime, default=datetime.utcnow)\n    expires_at = Column(DateTime)\n    executed_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nclass StrategyPerformance(Base):\n    __tablename__ = "strategy_performance"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    strategy_id = Column(Integer, index=True)\n    date = Column(DateTime, index=True)\n    daily_return = Column(Float)\n    cumulative_return = Column(Float)\n    sharpe_ratio = Column(Float)\n    max_drawdown = Column(Float)\n    win_rate = Column(Float)\n    total_trades = Column(Integer)\n    profitable_trades = Column(Integer)\n    avg_profit = Column(Float)\n    avg_loss = Column(Float)\n    aum = Column(Float)\n    metadata = Column(JSON)\n\nclass Subscription(Base):\n    __tablename__ = "subscriptions"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, index=True)\n    strategy_id = Column(Integer, index=True)\n    tier = Column(String)\n    amount_invested = Column(Float)\n    start_date = Column(DateTime, default=datetime.utcnow)\n    end_date = Column(DateTime, nullable=True)\n    is_active = Column(Boolean, default=True)\n    auto_renew = Column(Boolean, default=True)\n    total_return = Column(Float, default=0.0)\n    total_fees_paid = Column(Float, default=0.0)\n    metadata = Column(JSON)\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass AlphaStrategyCreate(BaseModel):\n    name: str\n    description: str\n    strategy_type: StrategyType\n    provider_id: int\n    risk_level: str = Field(..., pattern="^(low|medium|high)$")\n    min_investment: float = Field(gt=0)\n    performance_fee: float = Field(ge=0, le=50)\n    management_fee: float = Field(ge=0, le=10)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass AlphaStrategyUpdate(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n    risk_level: Optional[str] = None\n    min_investment: Optional[float] = None\n    performance_fee: Optional[float] = None\n    management_fee: Optional[float] = None\n    is_active: Optional[bool] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass SignalProviderCreate(BaseModel):\n    name: str\n    email: str\n    company: str\n    description: str\n    metadata: Optional[Dict[str, Any]] = None\n\nclass SignalProviderUpdate(BaseModel):\n    name: Optional[str] = None\n    company: Optional[str] = None\n    description: Optional[str] = None\n    status: Optional[ProviderStatus] = None\n    verification_status: Optional[str] = None\n    rating: Optional[float] = None\n    kyc_verified: Optional[bool] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass TradingSignalCreate(BaseModel):\n    strategy_id: int\n    provider_id: int\n    symbol: str\n    signal_type: SignalType\n    entry_price: float = Field(gt=0)\n    target_price: float = Field(gt=0)\n    stop_loss: float = Field(gt=0)\n    confidence: float = Field(ge=0, le=100)\n    timeframe: str\n    reasoning: str\n    expires_at: datetime\n    metadata: Optional[Dict[str, Any]] = None\n\nclass SubscriptionCreate(BaseModel):\n    user_id: int\n    strategy_id: int\n    tier: SubscriptionTier\n    amount_invested: float = Field(gt=0)\n    auto_renew: bool = True\n    metadata: Optional[Dict[str, Any]] = None\n\n# FastAPI app\napp = FastAPI(\n    title="TigerEx Alpha Market Admin API",\n    description="Admin panel for managing alpha trading strategies and signal providers",\n    version="1.0.0"\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# ==================== ALPHA STRATEGY ENDPOINTS ====================\n\n@app.post("/api/admin/strategies", status_code=201)\nasync def create_strategy(strategy: AlphaStrategyCreate, db: Session = Depends(get_db)):\n    """Create a new alpha trading strategy"""\n    try:\n        # Check if strategy name already exists\n        existing = db.query(AlphaStrategy).filter(AlphaStrategy.name == strategy.name).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Strategy name already exists")\n        \n        # Check if provider exists\n        provider = db.query(SignalProvider).filter(SignalProvider.id == strategy.provider_id).first()\n        if not provider:\n            raise HTTPException(status_code=404, detail="Signal provider not found")\n        \n        db_strategy = AlphaStrategy(**strategy.dict())\n        db.add(db_strategy)\n        \n        # Update provider stats\n        provider.total_strategies += 1\n        \n        db.commit()\n        db.refresh(db_strategy)\n        \n        logger.info(f"Created alpha strategy: {strategy.name}")\n        return db_strategy\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating strategy: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/strategies")\nasync def get_strategies(\n    skip: int = 0,\n    limit: int = 100,\n    strategy_type: Optional[StrategyType] = None,\n    provider_id: Optional[int] = None,\n    is_active: Optional[bool] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all alpha strategies with filters"""\n    try:\n        query = db.query(AlphaStrategy)\n        \n        if strategy_type:\n            query = query.filter(AlphaStrategy.strategy_type == strategy_type)\n        if provider_id:\n            query = query.filter(AlphaStrategy.provider_id == provider_id)\n        if is_active is not None:\n            query = query.filter(AlphaStrategy.is_active == is_active)\n        \n        total = query.count()\n        strategies = query.offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "strategies": strategies\n        }\n    except Exception as e:\n        logger.error(f"Error fetching strategies: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/strategies/{strategy_id}")\nasync def get_strategy(strategy_id: int, db: Session = Depends(get_db)):\n    """Get a specific alpha strategy"""\n    strategy = db.query(AlphaStrategy).filter(AlphaStrategy.id == strategy_id).first()\n    if not strategy:\n        raise HTTPException(status_code=404, detail="Strategy not found")\n    return strategy\n\n@app.put("/api/admin/strategies/{strategy_id}")\nasync def update_strategy(\n    strategy_id: int,\n    strategy_update: AlphaStrategyUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update an alpha strategy"""\n    try:\n        strategy = db.query(AlphaStrategy).filter(AlphaStrategy.id == strategy_id).first()\n        if not strategy:\n            raise HTTPException(status_code=404, detail="Strategy not found")\n        \n        update_data = strategy_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(strategy, field, value)\n        \n        strategy.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(strategy)\n        \n        logger.info(f"Updated strategy: {strategy_id}")\n        return strategy\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating strategy: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.delete("/api/admin/strategies/{strategy_id}")\nasync def delete_strategy(strategy_id: int, db: Session = Depends(get_db)):\n    """Delete an alpha strategy"""\n    try:\n        strategy = db.query(AlphaStrategy).filter(AlphaStrategy.id == strategy_id).first()\n        if not strategy:\n            raise HTTPException(status_code=404, detail="Strategy not found")\n        \n        # Check if strategy has active subscribers\n        active_subs = db.query(Subscription).filter(\n            Subscription.strategy_id == strategy_id,\n            Subscription.is_active == True\n        ).count()\n        \n        if active_subs > 0:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Cannot delete strategy with {active_subs} active subscribers"\n            )\n        \n        db.delete(strategy)\n        db.commit()\n        \n        logger.info(f"Deleted strategy: {strategy_id}")\n        return {"message": "Strategy deleted successfully"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error deleting strategy: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== SIGNAL PROVIDER ENDPOINTS ====================\n\n@app.post("/api/admin/providers", status_code=201)\nasync def create_provider(provider: SignalProviderCreate, db: Session = Depends(get_db)):\n    """Create a new signal provider"""\n    try:\n        # Check if email already exists\n        existing = db.query(SignalProvider).filter(SignalProvider.email == provider.email).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Email already registered")\n        \n        db_provider = SignalProvider(**provider.dict())\n        db.add(db_provider)\n        db.commit()\n        db.refresh(db_provider)\n        \n        logger.info(f"Created signal provider: {provider.name}")\n        return db_provider\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating provider: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/providers")\nasync def get_providers(\n    skip: int = 0,\n    limit: int = 100,\n    status: Optional[ProviderStatus] = None,\n    verification_status: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all signal providers with filters"""\n    try:\n        query = db.query(SignalProvider)\n        \n        if status:\n            query = query.filter(SignalProvider.status == status)\n        if verification_status:\n            query = query.filter(SignalProvider.verification_status == verification_status)\n        \n        total = query.count()\n        providers = query.offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "providers": providers\n        }\n    except Exception as e:\n        logger.error(f"Error fetching providers: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/providers/{provider_id}")\nasync def get_provider(provider_id: int, db: Session = Depends(get_db)):\n    """Get a specific signal provider"""\n    provider = db.query(SignalProvider).filter(SignalProvider.id == provider_id).first()\n    if not provider:\n        raise HTTPException(status_code=404, detail="Provider not found")\n    return provider\n\n@app.put("/api/admin/providers/{provider_id}")\nasync def update_provider(\n    provider_id: int,\n    provider_update: SignalProviderUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a signal provider"""\n    try:\n        provider = db.query(SignalProvider).filter(SignalProvider.id == provider_id).first()\n        if not provider:\n            raise HTTPException(status_code=404, detail="Provider not found")\n        \n        update_data = provider_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(provider, field, value)\n        \n        provider.last_active = datetime.utcnow()\n        db.commit()\n        db.refresh(provider)\n        \n        logger.info(f"Updated provider: {provider_id}")\n        return provider\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating provider: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/admin/providers/{provider_id}/verify")\nasync def verify_provider(provider_id: int, db: Session = Depends(get_db)):\n    """Verify a signal provider"""\n    try:\n        provider = db.query(SignalProvider).filter(SignalProvider.id == provider_id).first()\n        if not provider:\n            raise HTTPException(status_code=404, detail="Provider not found")\n        \n        provider.verification_status = "verified"\n        provider.kyc_verified = True\n        db.commit()\n        \n        logger.info(f"Verified provider: {provider_id}")\n        return {"message": "Provider verified successfully"}\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error verifying provider: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== TRADING SIGNAL ENDPOINTS ====================\n\n@app.post("/api/admin/signals", status_code=201)\nasync def create_signal(signal: TradingSignalCreate, db: Session = Depends(get_db)):\n    """Create a new trading signal"""\n    try:\n        # Verify strategy and provider exist\n        strategy = db.query(AlphaStrategy).filter(AlphaStrategy.id == signal.strategy_id).first()\n        if not strategy:\n            raise HTTPException(status_code=404, detail="Strategy not found")\n        \n        provider = db.query(SignalProvider).filter(SignalProvider.id == signal.provider_id).first()\n        if not provider:\n            raise HTTPException(status_code=404, detail="Provider not found")\n        \n        db_signal = TradingSignal(**signal.dict())\n        db.add(db_signal)\n        db.commit()\n        db.refresh(db_signal)\n        \n        logger.info(f"Created trading signal for {signal.symbol}")\n        return db_signal\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating signal: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/signals")\nasync def get_signals(\n    skip: int = 0,\n    limit: int = 100,\n    strategy_id: Optional[int] = None,\n    provider_id: Optional[int] = None,\n    symbol: Optional[str] = None,\n    status: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all trading signals with filters"""\n    try:\n        query = db.query(TradingSignal)\n        \n        if strategy_id:\n            query = query.filter(TradingSignal.strategy_id == strategy_id)\n        if provider_id:\n            query = query.filter(TradingSignal.provider_id == provider_id)\n        if symbol:\n            query = query.filter(TradingSignal.symbol == symbol)\n        if status:\n            query = query.filter(TradingSignal.status == status)\n        \n        total = query.count()\n        signals = query.order_by(TradingSignal.created_at.desc()).offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "signals": signals\n        }\n    except Exception as e:\n        logger.error(f"Error fetching signals: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.put("/api/admin/signals/{signal_id}/status")\nasync def update_signal_status(\n    signal_id: int,\n    status: str,\n    db: Session = Depends(get_db)\n):\n    """Update trading signal status"""\n    try:\n        signal = db.query(TradingSignal).filter(TradingSignal.id == signal_id).first()\n        if not signal:\n            raise HTTPException(status_code=404, detail="Signal not found")\n        \n        signal.status = status\n        if status == "executed":\n            signal.executed_at = datetime.utcnow()\n        \n        db.commit()\n        \n        logger.info(f"Updated signal {signal_id} status to {status}")\n        return {"message": "Signal status updated successfully"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating signal status: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== SUBSCRIPTION ENDPOINTS ====================\n\n@app.post("/api/admin/subscriptions", status_code=201)\nasync def create_subscription(subscription: SubscriptionCreate, db: Session = Depends(get_db)):\n    """Create a new strategy subscription"""\n    try:\n        # Verify strategy exists\n        strategy = db.query(AlphaStrategy).filter(AlphaStrategy.id == subscription.strategy_id).first()\n        if not strategy:\n            raise HTTPException(status_code=404, detail="Strategy not found")\n        \n        # Check minimum investment\n        if subscription.amount_invested < strategy.min_investment:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Minimum investment is {strategy.min_investment}"\n            )\n        \n        db_subscription = Subscription(**subscription.dict())\n        db.add(db_subscription)\n        \n        # Update strategy stats\n        strategy.active_subscribers += 1\n        strategy.aum += subscription.amount_invested\n        \n        db.commit()\n        db.refresh(db_subscription)\n        \n        logger.info(f"Created subscription for user {subscription.user_id}")\n        return db_subscription\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating subscription: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/subscriptions")\nasync def get_subscriptions(\n    skip: int = 0,\n    limit: int = 100,\n    user_id: Optional[int] = None,\n    strategy_id: Optional[int] = None,\n    is_active: Optional[bool] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all subscriptions with filters"""\n    try:\n        query = db.query(Subscription)\n        \n        if user_id:\n            query = query.filter(Subscription.user_id == user_id)\n        if strategy_id:\n            query = query.filter(Subscription.strategy_id == strategy_id)\n        if is_active is not None:\n            query = query.filter(Subscription.is_active == is_active)\n        \n        total = query.count()\n        subscriptions = query.offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "subscriptions": subscriptions\n        }\n    except Exception as e:\n        logger.error(f"Error fetching subscriptions: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.put("/api/admin/subscriptions/{subscription_id}/cancel")\nasync def cancel_subscription(subscription_id: int, db: Session = Depends(get_db)):\n    """Cancel a subscription"""\n    try:\n        subscription = db.query(Subscription).filter(Subscription.id == subscription_id).first()\n        if not subscription:\n            raise HTTPException(status_code=404, detail="Subscription not found")\n        \n        subscription.is_active = False\n        subscription.end_date = datetime.utcnow()\n        \n        # Update strategy stats\n        strategy = db.query(AlphaStrategy).filter(AlphaStrategy.id == subscription.strategy_id).first()\n        if strategy:\n            strategy.active_subscribers -= 1\n            strategy.aum -= subscription.amount_invested\n        \n        db.commit()\n        \n        logger.info(f"Cancelled subscription: {subscription_id}")\n        return {"message": "Subscription cancelled successfully"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error cancelling subscription: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== ANALYTICS ENDPOINTS ====================\n\n@app.get("/api/admin/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get overall alpha market analytics"""\n    try:\n        total_strategies = db.query(AlphaStrategy).count()\n        active_strategies = db.query(AlphaStrategy).filter(AlphaStrategy.is_active == True).count()\n        total_providers = db.query(SignalProvider).count()\n        verified_providers = db.query(SignalProvider).filter(\n            SignalProvider.verification_status == "verified"\n        ).count()\n        total_subscriptions = db.query(Subscription).filter(Subscription.is_active == True).count()\n        total_aum = db.query(AlphaStrategy).with_entities(\n            db.func.sum(AlphaStrategy.aum)\n        ).scalar() or 0.0\n        \n        # Recent signals\n        recent_signals = db.query(TradingSignal).filter(\n            TradingSignal.created_at >= datetime.utcnow() - timedelta(days=7)\n        ).count()\n        \n        return {\n            "total_strategies": total_strategies,\n            "active_strategies": active_strategies,\n            "total_providers": total_providers,\n            "verified_providers": verified_providers,\n            "total_subscriptions": total_subscriptions,\n            "total_aum": total_aum,\n            "recent_signals_7d": recent_signals\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/top-strategies")\nasync def get_top_strategies(limit: int = 10, db: Session = Depends(get_db)):\n    """Get top performing strategies"""\n    try:\n        strategies = db.query(AlphaStrategy).filter(\n            AlphaStrategy.is_active == True\n        ).order_by(\n            AlphaStrategy.total_return.desc()\n        ).limit(limit).all()\n        \n        return strategies\n    except Exception as e:\n        logger.error(f"Error fetching top strategies: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/top-providers")\nasync def get_top_providers(limit: int = 10, db: Session = Depends(get_db)):\n    """Get top signal providers"""\n    try:\n        providers = db.query(SignalProvider).filter(\n            SignalProvider.status == "active"\n        ).order_by(\n            SignalProvider.total_aum.desc()\n        ).limit(limit).all()\n        \n        return providers\n    except Exception as e:\n        logger.error(f"Error fetching top providers: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Health check\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "alpha-market-admin"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8115)\n</create-file>\n</function_calls>'}