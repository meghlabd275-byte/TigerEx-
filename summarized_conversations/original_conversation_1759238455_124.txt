{'role': 'assistant', 'content': 'Now let me create the Options Trading Admin Panel:\n\n<function_calls>\n<create-file file_path="backend/options-trading-admin/src/main.py">\n"""\nTigerEx Options Trading Admin Panel Service\nComprehensive admin panel for managing options contracts, Greeks monitoring, and risk management\n"""\n\nimport asyncio\nimport json\nimport logging\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom typing import Dict, List, Optional\nfrom enum import Enum\nimport math\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, validator\nfrom sqlalchemy import create_engine, Column, String, DECIMAL, DateTime, Boolean, Integer, Text, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport redis\nimport numpy as np\nfrom scipy.stats import norm\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(\n    title="TigerEx Options Trading Admin Panel",\n    description="Admin panel for options contract management and risk monitoring",\n    version="1.0.0"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Database setup\nDATABASE_URL = "postgresql://postgres:password@localhost/tigerex_options_admin"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Redis setup\nredis_client = redis.Redis(host=\'localhost\', port=6379, db=0, decode_responses=True)\n\n# Enums\nclass OptionType(str, Enum):\n    CALL = "call"\n    PUT = "put"\n\nclass OptionStyle(str, Enum):\n    EUROPEAN = "european"\n    AMERICAN = "american"\n\nclass ContractStatus(str, Enum):\n    ACTIVE = "active"\n    SUSPENDED = "suspended"\n    EXPIRED = "expired"\n    SETTLED = "settled"\n\n# Database Models\nclass OptionsContractDB(Base):\n    __tablename__ = "options_contracts"\n    \n    id = Column(String, primary_key=True)\n    symbol = Column(String, unique=True, nullable=False)\n    underlying_asset = Column(String, nullable=False)\n    option_type = Column(String, nullable=False)  # call, put\n    option_style = Column(String, nullable=False)  # european, american\n    strike_price = Column(DECIMAL(20, 8), nullable=False)\n    expiry_date = Column(DateTime, nullable=False)\n    contract_size = Column(DECIMAL(20, 8), default=1.0)\n    premium = Column(DECIMAL(20, 8), default=0.0)\n    open_interest = Column(Integer, default=0)\n    volume_24h = Column(DECIMAL(30, 8), default=0.0)\n    implied_volatility = Column(DECIMAL(10, 4), default=0.0)\n    status = Column(String, default="active")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass GreeksDataDB(Base):\n    __tablename__ = "greeks_data"\n    \n    id = Column(String, primary_key=True)\n    contract_id = Column(String, nullable=False)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    delta = Column(DECIMAL(10, 6))\n    gamma = Column(DECIMAL(10, 6))\n    theta = Column(DECIMAL(10, 6))\n    vega = Column(DECIMAL(10, 6))\n    rho = Column(DECIMAL(10, 6))\n    underlying_price = Column(DECIMAL(20, 8))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass OptionsPositionDB(Base):\n    __tablename__ = "options_positions"\n    \n    id = Column(String, primary_key=True)\n    user_id = Column(String, nullable=False)\n    contract_id = Column(String, nullable=False)\n    position_type = Column(String, nullable=False)  # long, short\n    quantity = Column(DECIMAL(20, 8), nullable=False)\n    entry_price = Column(DECIMAL(20, 8), nullable=False)\n    current_price = Column(DECIMAL(20, 8), default=0.0)\n    unrealized_pnl = Column(DECIMAL(20, 8), default=0.0)\n    margin_required = Column(DECIMAL(20, 8), default=0.0)\n    status = Column(String, default="open")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    closed_at = Column(DateTime)\n\nclass VolatilitySurfaceDB(Base):\n    __tablename__ = "volatility_surface"\n    \n    id = Column(String, primary_key=True)\n    underlying_asset = Column(String, nullable=False)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    strike_price = Column(DECIMAL(20, 8), nullable=False)\n    days_to_expiry = Column(Integer, nullable=False)\n    implied_volatility = Column(DECIMAL(10, 4), nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass SettlementHistoryDB(Base):\n    __tablename__ = "settlement_history"\n    \n    id = Column(String, primary_key=True)\n    contract_id = Column(String, nullable=False)\n    settlement_date = Column(DateTime, default=datetime.utcnow)\n    settlement_price = Column(DECIMAL(20, 8), nullable=False)\n    total_contracts = Column(Integer, default=0)\n    total_payout = Column(DECIMAL(30, 8), default=0.0)\n    status = Column(String, default="completed")\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Greeks Calculation Functions\ndef calculate_d1(S, K, T, r, sigma):\n    """Calculate d1 for Black-Scholes"""\n    return (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n\ndef calculate_d2(S, K, T, r, sigma):\n    """Calculate d2 for Black-Scholes"""\n    return calculate_d1(S, K, T, r, sigma) - sigma * np.sqrt(T)\n\ndef calculate_delta(S, K, T, r, sigma, option_type):\n    """Calculate Delta"""\n    d1 = calculate_d1(S, K, T, r, sigma)\n    if option_type == "call":\n        return norm.cdf(d1)\n    else:\n        return norm.cdf(d1) - 1\n\ndef calculate_gamma(S, K, T, r, sigma):\n    """Calculate Gamma"""\n    d1 = calculate_d1(S, K, T, r, sigma)\n    return norm.pdf(d1) / (S * sigma * np.sqrt(T))\n\ndef calculate_theta(S, K, T, r, sigma, option_type):\n    """Calculate Theta"""\n    d1 = calculate_d1(S, K, T, r, sigma)\n    d2 = calculate_d2(S, K, T, r, sigma)\n    \n    if option_type == "call":\n        theta = (-S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) \n                 - r * K * np.exp(-r * T) * norm.cdf(d2))\n    else:\n        theta = (-S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) \n                 + r * K * np.exp(-r * T) * norm.cdf(-d2))\n    \n    return theta / 365  # Daily theta\n\ndef calculate_vega(S, K, T, r, sigma):\n    """Calculate Vega"""\n    d1 = calculate_d1(S, K, T, r, sigma)\n    return S * norm.pdf(d1) * np.sqrt(T) / 100  # Per 1% change in volatility\n\ndef calculate_rho(S, K, T, r, sigma, option_type):\n    """Calculate Rho"""\n    d2 = calculate_d2(S, K, T, r, sigma)\n    \n    if option_type == "call":\n        return K * T * np.exp(-r * T) * norm.cdf(d2) / 100\n    else:\n        return -K * T * np.exp(-r * T) * norm.cdf(-d2) / 100\n\n# Pydantic Models\nclass OptionsContractCreate(BaseModel):\n    symbol: str\n    underlying_asset: str\n    option_type: OptionType\n    option_style: OptionStyle\n    strike_price: Decimal\n    expiry_date: datetime\n    contract_size: Decimal = Decimal("1.0")\n    premium: Decimal = Decimal("0.0")\n\nclass OptionsContractUpdate(BaseModel):\n    premium: Optional[Decimal]\n    implied_volatility: Optional[Decimal]\n    status: Optional[ContractStatus]\n\nclass OptionsContractResponse(BaseModel):\n    id: str\n    symbol: str\n    underlying_asset: str\n    option_type: str\n    option_style: str\n    strike_price: Decimal\n    expiry_date: datetime\n    contract_size: Decimal\n    premium: Decimal\n    open_interest: int\n    volume_24h: Decimal\n    implied_volatility: Decimal\n    status: str\n    created_at: datetime\n\nclass GreeksResponse(BaseModel):\n    contract_id: str\n    delta: Decimal\n    gamma: Decimal\n    theta: Decimal\n    vega: Decimal\n    rho: Decimal\n    underlying_price: Decimal\n    timestamp: datetime\n\nclass OptionsStatistics(BaseModel):\n    total_contracts: int\n    active_contracts: int\n    total_open_interest: int\n    total_volume_24h: Decimal\n    total_premium_collected: Decimal\n    pending_settlements: int\n\n# API Endpoints\n\n@app.post("/admin/options/contracts", response_model=OptionsContractResponse)\nasync def create_options_contract(\n    contract: OptionsContractCreate,\n    db: Session = Depends(get_db)\n):\n    """Create a new options contract"""\n    import uuid\n    \n    # Check if symbol already exists\n    existing = db.query(OptionsContractDB).filter(\n        OptionsContractDB.symbol == contract.symbol\n    ).first()\n    if existing:\n        raise HTTPException(status_code=400, detail="Contract symbol already exists")\n    \n    # Validate expiry date\n    if contract.expiry_date <= datetime.utcnow():\n        raise HTTPException(status_code=400, detail="Expiry date must be in the future")\n    \n    contract_id = str(uuid.uuid4())\n    db_contract = OptionsContractDB(\n        id=contract_id,\n        symbol=contract.symbol,\n        underlying_asset=contract.underlying_asset,\n        option_type=contract.option_type,\n        option_style=contract.option_style,\n        strike_price=contract.strike_price,\n        expiry_date=contract.expiry_date,\n        contract_size=contract.contract_size,\n        premium=contract.premium,\n        status="active",\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(db_contract)\n    db.commit()\n    db.refresh(db_contract)\n    \n    logger.info(f"Created options contract: {contract.symbol}")\n    \n    return OptionsContractResponse(\n        id=db_contract.id,\n        symbol=db_contract.symbol,\n        underlying_asset=db_contract.underlying_asset,\n        option_type=db_contract.option_type,\n        option_style=db_contract.option_style,\n        strike_price=db_contract.strike_price,\n        expiry_date=db_contract.expiry_date,\n        contract_size=db_contract.contract_size,\n        premium=db_contract.premium,\n        open_interest=db_contract.open_interest,\n        volume_24h=db_contract.volume_24h,\n        implied_volatility=db_contract.implied_volatility,\n        status=db_contract.status,\n        created_at=db_contract.created_at\n    )\n\n@app.get("/admin/options/contracts", response_model=List[OptionsContractResponse])\nasync def list_options_contracts(\n    underlying_asset: Optional[str] = None,\n    option_type: Optional[str] = None,\n    status: Optional[str] = None,\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db)\n):\n    """List all options contracts"""\n    query = db.query(OptionsContractDB)\n    \n    if underlying_asset:\n        query = query.filter(OptionsContractDB.underlying_asset == underlying_asset)\n    if option_type:\n        query = query.filter(OptionsContractDB.option_type == option_type)\n    if status:\n        query = query.filter(OptionsContractDB.status == status)\n    \n    contracts = query.offset(skip).limit(limit).all()\n    \n    return [OptionsContractResponse(\n        id=c.id,\n        symbol=c.symbol,\n        underlying_asset=c.underlying_asset,\n        option_type=c.option_type,\n        option_style=c.option_style,\n        strike_price=c.strike_price,\n        expiry_date=c.expiry_date,\n        contract_size=c.contract_size,\n        premium=c.premium,\n        open_interest=c.open_interest,\n        volume_24h=c.volume_24h,\n        implied_volatility=c.implied_volatility,\n        status=c.status,\n        created_at=c.created_at\n    ) for c in contracts]\n\n@app.get("/admin/options/greeks/{contract_id}", response_model=GreeksResponse)\nasync def get_contract_greeks(\n    contract_id: str,\n    underlying_price: float,\n    risk_free_rate: float = 0.05,\n    db: Session = Depends(get_db)\n):\n    """Calculate and return Greeks for a contract"""\n    import uuid\n    \n    contract = db.query(OptionsContractDB).filter(\n        OptionsContractDB.id == contract_id\n    ).first()\n    if not contract:\n        raise HTTPException(status_code=404, detail="Contract not found")\n    \n    # Calculate time to expiry in years\n    T = (contract.expiry_date - datetime.utcnow()).total_seconds() / (365.25 * 24 * 3600)\n    if T <= 0:\n        raise HTTPException(status_code=400, detail="Contract has expired")\n    \n    S = underlying_price\n    K = float(contract.strike_price)\n    r = risk_free_rate\n    sigma = float(contract.implied_volatility) if contract.implied_volatility > 0 else 0.3\n    \n    # Calculate Greeks\n    delta = calculate_delta(S, K, T, r, sigma, contract.option_type)\n    gamma = calculate_gamma(S, K, T, r, sigma)\n    theta = calculate_theta(S, K, T, r, sigma, contract.option_type)\n    vega = calculate_vega(S, K, T, r, sigma)\n    rho = calculate_rho(S, K, T, r, sigma, contract.option_type)\n    \n    # Store Greeks in database\n    greeks_id = str(uuid.uuid4())\n    greeks_data = GreeksDataDB(\n        id=greeks_id,\n        contract_id=contract_id,\n        timestamp=datetime.utcnow(),\n        delta=Decimal(str(delta)),\n        gamma=Decimal(str(gamma)),\n        theta=Decimal(str(theta)),\n        vega=Decimal(str(vega)),\n        rho=Decimal(str(rho)),\n        underlying_price=Decimal(str(underlying_price)),\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(greeks_data)\n    db.commit()\n    \n    return GreeksResponse(\n        contract_id=contract_id,\n        delta=Decimal(str(delta)),\n        gamma=Decimal(str(gamma)),\n        theta=Decimal(str(theta)),\n        vega=Decimal(str(vega)),\n        rho=Decimal(str(rho)),\n        underlying_price=Decimal(str(underlying_price)),\n        timestamp=datetime.utcnow()\n    )\n\n@app.get("/admin/options/statistics", response_model=OptionsStatistics)\nasync def get_options_statistics(db: Session = Depends(get_db)):\n    """Get options platform statistics"""\n    total_contracts = db.query(OptionsContractDB).count()\n    active_contracts = db.query(OptionsContractDB).filter(\n        OptionsContractDB.status == "active"\n    ).count()\n    \n    # Calculate total open interest\n    contracts = db.query(OptionsContractDB).filter(\n        OptionsContractDB.status == "active"\n    ).all()\n    total_open_interest = sum(c.open_interest for c in contracts)\n    \n    # Calculate 24h volume\n    total_volume_24h = sum(c.volume_24h for c in contracts)\n    \n    # Calculate total premium collected\n    total_premium = sum(c.premium * c.open_interest for c in contracts)\n    \n    # Count pending settlements\n    pending_settlements = db.query(SettlementHistoryDB).filter(\n        SettlementHistoryDB.status == "pending"\n    ).count()\n    \n    return OptionsStatistics(\n        total_contracts=total_contracts,\n        active_contracts=active_contracts,\n        total_open_interest=total_open_interest,\n        total_volume_24h=Decimal(str(total_volume_24h)),\n        total_premium_collected=Decimal(str(total_premium)),\n        pending_settlements=pending_settlements\n    )\n\n@app.post("/admin/options/settle/{contract_id}")\nasync def settle_contract(\n    contract_id: str,\n    settlement_price: Decimal,\n    db: Session = Depends(get_db)\n):\n    """Settle an expired options contract"""\n    import uuid\n    \n    contract = db.query(OptionsContractDB).filter(\n        OptionsContractDB.id == contract_id\n    ).first()\n    if not contract:\n        raise HTTPException(status_code=404, detail="Contract not found")\n    \n    if contract.expiry_date > datetime.utcnow():\n        raise HTTPException(status_code=400, detail="Contract has not expired yet")\n    \n    # Calculate total payout\n    if contract.option_type == "call":\n        payout_per_contract = max(0, settlement_price - contract.strike_price)\n    else:  # put\n        payout_per_contract = max(0, contract.strike_price - settlement_price)\n    \n    total_payout = payout_per_contract * contract.open_interest * contract.contract_size\n    \n    # Create settlement record\n    settlement_id = str(uuid.uuid4())\n    settlement = SettlementHistoryDB(\n        id=settlement_id,\n        contract_id=contract_id,\n        settlement_date=datetime.utcnow(),\n        settlement_price=settlement_price,\n        total_contracts=contract.open_interest,\n        total_payout=total_payout,\n        status="completed",\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(settlement)\n    \n    # Update contract status\n    contract.status = "settled"\n    contract.updated_at = datetime.utcnow()\n    \n    db.commit()\n    \n    logger.info(f"Settled contract: {contract.symbol}, Total payout: {total_payout}")\n    \n    return {\n        "message": "Contract settled successfully",\n        "settlement_id": settlement_id,\n        "total_payout": float(total_payout)\n    }\n\n@app.get("/admin/options/volatility-surface/{underlying_asset}")\nasync def get_volatility_surface(\n    underlying_asset: str,\n    db: Session = Depends(get_db)\n):\n    """Get volatility surface for an underlying asset"""\n    surface_data = db.query(VolatilitySurfaceDB).filter(\n        VolatilitySurfaceDB.underlying_asset == underlying_asset\n    ).order_by(\n        VolatilitySurfaceDB.days_to_expiry,\n        VolatilitySurfaceDB.strike_price\n    ).all()\n    \n    return [{\n        "strike_price": float(data.strike_price),\n        "days_to_expiry": data.days_to_expiry,\n        "implied_volatility": float(data.implied_volatility),\n        "timestamp": data.timestamp.isoformat()\n    } for data in surface_data]\n\n@app.get("/admin/options/positions")\nasync def list_options_positions(\n    status: Optional[str] = None,\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db)\n):\n    """List all options positions"""\n    query = db.query(OptionsPositionDB)\n    \n    if status:\n        query = query.filter(OptionsPositionDB.status == status)\n    \n    positions = query.order_by(OptionsPositionDB.created_at.desc()).offset(skip).limit(limit).all()\n    \n    return [{\n        "id": pos.id,\n        "user_id": pos.user_id,\n        "contract_id": pos.contract_id,\n        "position_type": pos.position_type,\n        "quantity": float(pos.quantity),\n        "entry_price": float(pos.entry_price),\n        "current_price": float(pos.current_price),\n        "unrealized_pnl": float(pos.unrealized_pnl),\n        "margin_required": float(pos.margin_required),\n        "status": pos.status,\n        "created_at": pos.created_at.isoformat()\n    } for pos in positions]\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "options-trading-admin"}\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8114)\n</create-file>\n</function_calls>'}