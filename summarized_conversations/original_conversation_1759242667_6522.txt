{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/nft-marketplace-admin/src/main.py">\n"""\nTigerEx NFT Marketplace Admin Panel\nManages NFT collections, listings, and marketplace operations\nPort: 8119\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_nft_marketplace"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass NFTStandard(str, Enum):\n    ERC721 = "erc721"\n    ERC1155 = "erc1155"\n    SPL = "spl"\n\nclass CollectionStatus(str, Enum):\n    PENDING = "pending"\n    VERIFIED = "verified"\n    FEATURED = "featured"\n    SUSPENDED = "suspended"\n\nclass NFTCollection(Base):\n    __tablename__ = "nft_collections"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    symbol = Column(String)\n    description = Column(Text)\n    contract_address = Column(String, unique=True, index=True)\n    chain = Column(String)\n    standard = Column(String)\n    creator_address = Column(String, index=True)\n    status = Column(String, default="pending")\n    is_verified = Column(Boolean, default=False)\n    is_featured = Column(Boolean, default=False)\n    total_supply = Column(Integer, default=0)\n    floor_price = Column(Float, default=0.0)\n    total_volume = Column(Float, default=0.0)\n    total_sales = Column(Integer, default=0)\n    royalty_percentage = Column(Float, default=0.0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass NFTListing(Base):\n    __tablename__ = "nft_listings"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    collection_id = Column(Integer, index=True)\n    token_id = Column(String, index=True)\n    seller_address = Column(String, index=True)\n    price = Column(Float)\n    currency = Column(String)\n    status = Column(String, default="active")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    expires_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nclass NFTSale(Base):\n    __tablename__ = "nft_sales"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    listing_id = Column(Integer, index=True)\n    collection_id = Column(Integer, index=True)\n    token_id = Column(String, index=True)\n    seller_address = Column(String, index=True)\n    buyer_address = Column(String, index=True)\n    price = Column(Float)\n    currency = Column(String)\n    tx_hash = Column(String, unique=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nBase.metadata.create_all(bind=engine)\n\nclass NFTCollectionCreate(BaseModel):\n    name: str\n    symbol: str\n    description: str\n    contract_address: str\n    chain: str\n    standard: NFTStandard\n    creator_address: str\n    royalty_percentage: float = Field(ge=0, le=10, default=0.0)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass NFTCollectionUpdate(BaseModel):\n    description: Optional[str] = None\n    status: Optional[CollectionStatus] = None\n    is_verified: Optional[bool] = None\n    is_featured: Optional[bool] = None\n    floor_price: Optional[float] = None\n    royalty_percentage: Optional[float] = None\n    metadata: Optional[Dict[str, Any]] = None\n\napp = FastAPI(title="TigerEx NFT Marketplace Admin API", version="1.0.0")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post("/api/admin/collections", status_code=201)\nasync def create_collection(collection: NFTCollectionCreate, db: Session = Depends(get_db)):\n    """Create a new NFT collection"""\n    try:\n        existing = db.query(NFTCollection).filter(\n            NFTCollection.contract_address == collection.contract_address\n        ).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Collection already exists")\n        \n        db_collection = NFTCollection(**collection.dict())\n        db.add(db_collection)\n        db.commit()\n        db.refresh(db_collection)\n        \n        logger.info(f"Created NFT collection: {collection.name}")\n        return db_collection\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating collection: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/collections")\nasync def get_collections(\n    skip: int = 0,\n    limit: int = 100,\n    status: Optional[CollectionStatus] = None,\n    is_verified: Optional[bool] = None,\n    is_featured: Optional[bool] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all NFT collections"""\n    try:\n        query = db.query(NFTCollection)\n        \n        if status:\n            query = query.filter(NFTCollection.status == status)\n        if is_verified is not None:\n            query = query.filter(NFTCollection.is_verified == is_verified)\n        if is_featured is not None:\n            query = query.filter(NFTCollection.is_featured == is_featured)\n        \n        total = query.count()\n        collections = query.order_by(NFTCollection.total_volume.desc()).offset(skip).limit(limit).all()\n        \n        return {"total": total, "collections": collections}\n    except Exception as e:\n        logger.error(f"Error fetching collections: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.put("/api/admin/collections/{collection_id}")\nasync def update_collection(\n    collection_id: int,\n    collection_update: NFTCollectionUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update an NFT collection"""\n    try:\n        collection = db.query(NFTCollection).filter(NFTCollection.id == collection_id).first()\n        if not collection:\n            raise HTTPException(status_code=404, detail="Collection not found")\n        \n        update_data = collection_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(collection, field, value)\n        \n        db.commit()\n        db.refresh(collection)\n        \n        logger.info(f"Updated collection: {collection_id}")\n        return collection\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating collection: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/admin/collections/{collection_id}/verify")\nasync def verify_collection(collection_id: int, db: Session = Depends(get_db)):\n    """Verify an NFT collection"""\n    try:\n        collection = db.query(NFTCollection).filter(NFTCollection.id == collection_id).first()\n        if not collection:\n            raise HTTPException(status_code=404, detail="Collection not found")\n        \n        collection.is_verified = True\n        collection.status = "verified"\n        db.commit()\n        \n        logger.info(f"Verified collection: {collection_id}")\n        return {"message": "Collection verified successfully"}\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error verifying collection: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get NFT marketplace analytics"""\n    try:\n        total_collections = db.query(NFTCollection).count()\n        verified_collections = db.query(NFTCollection).filter(\n            NFTCollection.is_verified == True\n        ).count()\n        total_listings = db.query(NFTListing).filter(NFTListing.status == "active").count()\n        total_volume = db.query(NFTCollection).with_entities(\n            db.func.sum(NFTCollection.total_volume)\n        ).scalar() or 0.0\n        total_sales = db.query(NFTSale).count()\n        \n        return {\n            "total_collections": total_collections,\n            "verified_collections": verified_collections,\n            "total_listings": total_listings,\n            "total_volume": total_volume,\n            "total_sales": total_sales\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "nft-marketplace-admin"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8119)\n</create-file>\n</function_calls>'}