{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/payment-gateway-admin/src/main.py">\n"""\nTigerEx Payment Gateway Admin Panel\nManages payment providers, transactions, and fiat on/off ramps\nPort: 8122\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_payment_gateway"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass ProviderType(str, Enum):\n    CARD = "card"\n    BANK_TRANSFER = "bank_transfer"\n    DIGITAL_WALLET = "digital_wallet"\n    BNPL = "bnpl"  # Buy Now Pay Later\n\nclass ProviderStatus(str, Enum):\n    ACTIVE = "active"\n    INACTIVE = "inactive"\n    MAINTENANCE = "maintenance"\n\nclass PaymentProvider(Base):\n    __tablename__ = "payment_providers"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    provider_type = Column(String)\n    api_endpoint = Column(String)\n    api_key_encrypted = Column(String)\n    is_enabled = Column(Boolean, default=True)\n    status = Column(String, default="active")\n    \n    # Supported features\n    supports_deposits = Column(Boolean, default=True)\n    supports_withdrawals = Column(Boolean, default=True)\n    supports_refunds = Column(Boolean, default=True)\n    \n    # Limits\n    min_transaction_amount = Column(Float, default=10.0)\n    max_transaction_amount = Column(Float, default=50000.0)\n    daily_limit = Column(Float, default=100000.0)\n    \n    # Fees\n    deposit_fee_percentage = Column(Float, default=2.5)\n    withdrawal_fee_percentage = Column(Float, default=1.0)\n    fixed_fee = Column(Float, default=0.0)\n    \n    # Stats\n    total_transactions = Column(Integer, default=0)\n    total_volume = Column(Float, default=0.0)\n    success_rate = Column(Float, default=100.0)\n    avg_processing_time = Column(Float, default=0.0)\n    \n    # Supported currencies and countries\n    supported_currencies = Column(JSON)\n    supported_countries = Column(JSON)\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass PaymentTransaction(Base):\n    __tablename__ = "payment_transactions"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    provider_id = Column(Integer, index=True)\n    user_id = Column(Integer, index=True)\n    transaction_type = Column(String)  # deposit, withdrawal\n    amount = Column(Float)\n    currency = Column(String)\n    fee = Column(Float)\n    net_amount = Column(Float)\n    status = Column(String, default="pending")\n    payment_method = Column(String)\n    external_transaction_id = Column(String, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nclass FiatOnRamp(Base):\n    __tablename__ = "fiat_onramps"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    provider_id = Column(Integer, index=True)\n    user_id = Column(Integer, index=True)\n    fiat_amount = Column(Float)\n    fiat_currency = Column(String)\n    crypto_amount = Column(Float)\n    crypto_currency = Column(String)\n    exchange_rate = Column(Float)\n    status = Column(String, default="pending")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nclass FiatOffRamp(Base):\n    __tablename__ = "fiat_offramps"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    provider_id = Column(Integer, index=True)\n    user_id = Column(Integer, index=True)\n    crypto_amount = Column(Float)\n    crypto_currency = Column(String)\n    fiat_amount = Column(Float)\n    fiat_currency = Column(String)\n    exchange_rate = Column(Float)\n    status = Column(String, default="pending")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nBase.metadata.create_all(bind=engine)\n\nclass PaymentProviderCreate(BaseModel):\n    name: str\n    provider_type: ProviderType\n    api_endpoint: str\n    api_key_encrypted: str\n    supports_deposits: bool = True\n    supports_withdrawals: bool = True\n    supports_refunds: bool = True\n    min_transaction_amount: float = Field(ge=0, default=10.0)\n    max_transaction_amount: float = Field(ge=0, default=50000.0)\n    daily_limit: float = Field(ge=0, default=100000.0)\n    deposit_fee_percentage: float = Field(ge=0, le=10, default=2.5)\n    withdrawal_fee_percentage: float = Field(ge=0, le=10, default=1.0)\n    fixed_fee: float = Field(ge=0, default=0.0)\n    supported_currencies: List[str] = []\n    supported_countries: List[str] = []\n    metadata: Optional[Dict[str, Any]] = None\n\nclass PaymentProviderUpdate(BaseModel):\n    api_endpoint: Optional[str] = None\n    is_enabled: Optional[bool] = None\n    status: Optional[ProviderStatus] = None\n    min_transaction_amount: Optional[float] = None\n    max_transaction_amount: Optional[float] = None\n    daily_limit: Optional[float] = None\n    deposit_fee_percentage: Optional[float] = None\n    withdrawal_fee_percentage: Optional[float] = None\n    fixed_fee: Optional[float] = None\n    supported_currencies: Optional[List[str]] = None\n    supported_countries: Optional[List[str]] = None\n    metadata: Optional[Dict[str, Any]] = None\n\napp = FastAPI(title="TigerEx Payment Gateway Admin API", version="1.0.0")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post("/api/admin/providers", status_code=201)\nasync def create_provider(provider: PaymentProviderCreate, db: Session = Depends(get_db)):\n    """Create a new payment provider"""\n    try:\n        existing = db.query(PaymentProvider).filter(PaymentProvider.name == provider.name).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Provider already exists")\n        \n        db_provider = PaymentProvider(**provider.dict())\n        db.add(db_provider)\n        db.commit()\n        db.refresh(db_provider)\n        \n        logger.info(f"Created payment provider: {provider.name}")\n        return db_provider\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating provider: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/providers")\nasync def get_providers(\n    skip: int = 0,\n    limit: int = 100,\n    provider_type: Optional[ProviderType] = None,\n    is_enabled: Optional[bool] = None,\n    status: Optional[ProviderStatus] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all payment providers"""\n    try:\n        query = db.query(PaymentProvider)\n        \n        if provider_type:\n            query = query.filter(PaymentProvider.provider_type == provider_type)\n        if is_enabled is not None:\n            query = query.filter(PaymentProvider.is_enabled == is_enabled)\n        if status:\n            query = query.filter(PaymentProvider.status == status)\n        \n        total = query.count()\n        providers = query.order_by(PaymentProvider.total_volume.desc()).offset(skip).limit(limit).all()\n        \n        return {"total": total, "providers": providers}\n    except Exception as e:\n        logger.error(f"Error fetching providers: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.put("/api/admin/providers/{provider_id}")\nasync def update_provider(\n    provider_id: int,\n    provider_update: PaymentProviderUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a payment provider"""\n    try:\n        provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()\n        if not provider:\n            raise HTTPException(status_code=404, detail="Provider not found")\n        \n        update_data = provider_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(provider, field, value)\n        \n        provider.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(provider)\n        \n        logger.info(f"Updated provider: {provider_id}")\n        return provider\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating provider: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/transactions")\nasync def get_transactions(\n    skip: int = 0,\n    limit: int = 100,\n    provider_id: Optional[int] = None,\n    transaction_type: Optional[str] = None,\n    status: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all payment transactions"""\n    try:\n        query = db.query(PaymentTransaction)\n        \n        if provider_id:\n            query = query.filter(PaymentTransaction.provider_id == provider_id)\n        if transaction_type:\n            query = query.filter(PaymentTransaction.transaction_type == transaction_type)\n        if status:\n            query = query.filter(PaymentTransaction.status == status)\n        \n        total = query.count()\n        transactions = query.order_by(PaymentTransaction.created_at.desc()).offset(skip).limit(limit).all()\n        \n        return {"total": total, "transactions": transactions}\n    except Exception as e:\n        logger.error(f"Error fetching transactions: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get payment gateway analytics"""\n    try:\n        total_providers = db.query(PaymentProvider).count()\n        active_providers = db.query(PaymentProvider).filter(\n            PaymentProvider.is_enabled == True,\n            PaymentProvider.status == "active"\n        ).count()\n        total_transactions = db.query(PaymentTransaction).count()\n        total_volume = db.query(PaymentProvider).with_entities(\n            db.func.sum(PaymentProvider.total_volume)\n        ).scalar() or 0.0\n        avg_success_rate = db.query(PaymentProvider).filter(\n            PaymentProvider.is_enabled == True\n        ).with_entities(db.func.avg(PaymentProvider.success_rate)).scalar() or 0.0\n        \n        return {\n            "total_providers": total_providers,\n            "active_providers": active_providers,\n            "total_transactions": total_transactions,\n            "total_volume": total_volume,\n            "avg_success_rate": avg_success_rate\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "payment-gateway-admin"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8122)\n</create-file>\n</function_calls>'}