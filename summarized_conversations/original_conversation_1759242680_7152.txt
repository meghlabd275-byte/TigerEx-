{'role': 'assistant', 'content': '\n<function_calls>\n<create-file file_path="backend/advanced-trading-service/src/main.py">\n"""\nTigerEx Advanced Trading Service\nImplements advanced order types: TWAP, VWAP, and algorithmic trading\nPort: 8124\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\nimport asyncio\nfrom decimal import Decimal\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_advanced_trading"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass AdvancedOrderType(str, Enum):\n    TWAP = "twap"\n    VWAP = "vwap"\n    IMPLEMENTATION_SHORTFALL = "implementation_shortfall"\n    ARRIVAL_PRICE = "arrival_price"\n    PARTICIPATION_RATE = "participation_rate"\n    IF_TOUCHED = "if_touched"\n    CONTINGENT = "contingent"\n    TIME_BASED = "time_based"\n    VOLUME_BASED = "volume_based"\n\nclass OrderStatus(str, Enum):\n    PENDING = "pending"\n    ACTIVE = "active"\n    EXECUTING = "executing"\n    COMPLETED = "completed"\n    CANCELLED = "cancelled"\n    FAILED = "failed"\n    PAUSED = "paused"\n\nclass ExecutionStrategy(str, Enum):\n    AGGRESSIVE = "aggressive"\n    PASSIVE = "passive"\n    BALANCED = "balanced"\n\n# Database Models\nclass AdvancedOrder(Base):\n    __tablename__ = "advanced_orders"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(String, unique=True, index=True)\n    user_id = Column(Integer, index=True)\n    order_type = Column(String, index=True)\n    symbol = Column(String, index=True)\n    side = Column(String)\n    total_quantity = Column(Float)\n    executed_quantity = Column(Float, default=0.0)\n    remaining_quantity = Column(Float)\n    limit_price = Column(Float, nullable=True)\n    avg_execution_price = Column(Float, default=0.0)\n    start_time = Column(DateTime)\n    end_time = Column(DateTime)\n    duration_minutes = Column(Integer)\n    execution_strategy = Column(String, default="balanced")\n    participation_rate = Column(Float, nullable=True)\n    slice_size = Column(Float, nullable=True)\n    slice_interval_seconds = Column(Integer, nullable=True)\n    trigger_price = Column(Float, nullable=True)\n    contingent_order_id = Column(String, nullable=True)\n    status = Column(String, default="pending")\n    total_slices = Column(Integer, default=0)\n    executed_slices = Column(Integer, default=0)\n    failed_slices = Column(Integer, default=0)\n    slippage = Column(Float, default=0.0)\n    implementation_shortfall = Column(Float, default=0.0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    started_at = Column(DateTime, nullable=True)\n    completed_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nclass OrderSlice(Base):\n    __tablename__ = "order_slices"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(String, index=True)\n    slice_number = Column(Integer)\n    quantity = Column(Float)\n    executed_quantity = Column(Float, default=0.0)\n    price = Column(Float, nullable=True)\n    avg_execution_price = Column(Float, default=0.0)\n    status = Column(String, default="pending")\n    scheduled_time = Column(DateTime)\n    executed_at = Column(DateTime, nullable=True)\n    market_price = Column(Float, nullable=True)\n    market_volume = Column(Float, nullable=True)\n    metadata = Column(JSON)\n\nclass ExecutionReport(Base):\n    __tablename__ = "execution_reports"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(String, index=True)\n    total_quantity = Column(Float)\n    executed_quantity = Column(Float)\n    avg_price = Column(Float)\n    vwap = Column(Float, nullable=True)\n    twap = Column(Float, nullable=True)\n    arrival_price = Column(Float, nullable=True)\n    implementation_shortfall = Column(Float, nullable=True)\n    slippage_bps = Column(Float, nullable=True)\n    total_duration_seconds = Column(Integer)\n    avg_slice_duration_seconds = Column(Float)\n    market_impact_bps = Column(Float, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass TWAPOrderCreate(BaseModel):\n    user_id: int\n    symbol: str\n    side: str = Field(pattern="^(buy|sell)$")\n    total_quantity: float = Field(gt=0)\n    duration_minutes: int = Field(gt=0, le=1440)\n    limit_price: Optional[float] = None\n    execution_strategy: ExecutionStrategy = ExecutionStrategy.BALANCED\n    metadata: Optional[Dict[str, Any]] = None\n\nclass VWAPOrderCreate(BaseModel):\n    user_id: int\n    symbol: str\n    side: str = Field(pattern="^(buy|sell)$")\n    total_quantity: float = Field(gt=0)\n    duration_minutes: int = Field(gt=0, le=1440)\n    limit_price: Optional[float] = None\n    execution_strategy: ExecutionStrategy = ExecutionStrategy.BALANCED\n    metadata: Optional[Dict[str, Any]] = None\n\nclass ParticipationRateOrderCreate(BaseModel):\n    user_id: int\n    symbol: str\n    side: str = Field(pattern="^(buy|sell)$")\n    total_quantity: float = Field(gt=0)\n    participation_rate: float = Field(gt=0, le=100)\n    duration_minutes: int = Field(gt=0, le=1440)\n    limit_price: Optional[float] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass IfTouchedOrderCreate(BaseModel):\n    user_id: int\n    symbol: str\n    side: str = Field(pattern="^(buy|sell)$")\n    quantity: float = Field(gt=0)\n    trigger_price: float = Field(gt=0)\n    limit_price: Optional[float] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass ContingentOrderCreate(BaseModel):\n    user_id: int\n    symbol: str\n    side: str = Field(pattern="^(buy|sell)$")\n    quantity: float = Field(gt=0)\n    contingent_order_id: str\n    limit_price: Optional[float] = None\n    metadata: Optional[Dict[str, Any]] = None\n\napp = FastAPI(\n    title="TigerEx Advanced Trading Service",\n    description="Advanced order types and algorithmic trading",\n    version="1.0.0"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef generate_order_id(order_type: str) -> str:\n    import uuid\n    prefix = order_type.upper()[:4]\n    return f"{prefix}-{uuid.uuid4().hex[:12].upper()}"\n\ndef calculate_slice_parameters(total_quantity: float, duration_minutes: int, strategy: str) -> tuple:\n    if strategy == "aggressive":\n        num_slices = max(5, duration_minutes // 2)\n    elif strategy == "passive":\n        num_slices = max(10, duration_minutes)\n    else:\n        num_slices = max(8, duration_minutes // 3)\n    \n    slice_size = total_quantity / num_slices\n    slice_interval = (duration_minutes * 60) / num_slices\n    \n    return slice_size, int(slice_interval), num_slices\n\n@app.post("/api/orders/twap", status_code=201)\nasync def create_twap_order(order: TWAPOrderCreate, db: Session = Depends(get_db)):\n    try:\n        slice_size, slice_interval, num_slices = calculate_slice_parameters(\n            order.total_quantity, order.duration_minutes, order.execution_strategy\n        )\n        \n        start_time = datetime.utcnow()\n        end_time = start_time + timedelta(minutes=order.duration_minutes)\n        \n        db_order = AdvancedOrder(\n            order_id=generate_order_id("TWAP"),\n            user_id=order.user_id,\n            order_type="twap",\n            symbol=order.symbol,\n            side=order.side,\n            total_quantity=order.total_quantity,\n            remaining_quantity=order.total_quantity,\n            limit_price=order.limit_price,\n            start_time=start_time,\n            end_time=end_time,\n            duration_minutes=order.duration_minutes,\n            execution_strategy=order.execution_strategy,\n            slice_size=slice_size,\n            slice_interval_seconds=slice_interval,\n            total_slices=num_slices,\n            status="active",\n            started_at=start_time,\n            metadata=order.metadata or {}\n        )\n        \n        db.add(db_order)\n        db.commit()\n        db.refresh(db_order)\n        \n        for i in range(num_slices):\n            slice_time = start_time + timedelta(seconds=slice_interval * i)\n            slice_obj = OrderSlice(\n                order_id=db_order.order_id,\n                slice_number=i + 1,\n                quantity=slice_size,\n                scheduled_time=slice_time,\n                status="pending"\n            )\n            db.add(slice_obj)\n        \n        db.commit()\n        logger.info(f"Created TWAP order: {db_order.order_id}")\n        \n        return {\n            "order_id": db_order.order_id,\n            "order_type": "twap",\n            "symbol": db_order.symbol,\n            "side": db_order.side,\n            "total_quantity": db_order.total_quantity,\n            "num_slices": num_slices,\n            "slice_size": slice_size,\n            "slice_interval_seconds": slice_interval,\n            "start_time": db_order.start_time,\n            "end_time": db_order.end_time,\n            "status": db_order.status\n        }\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating TWAP order: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/orders/vwap", status_code=201)\nasync def create_vwap_order(order: VWAPOrderCreate, db: Session = Depends(get_db)):\n    try:\n        slice_size, slice_interval, num_slices = calculate_slice_parameters(\n            order.total_quantity, order.duration_minutes, order.execution_strategy\n        )\n        \n        start_time = datetime.utcnow()\n        end_time = start_time + timedelta(minutes=order.duration_minutes)\n        \n        db_order = AdvancedOrder(\n            order_id=generate_order_id("VWAP"),\n            user_id=order.user_id,\n            order_type="vwap",\n            symbol=order.symbol,\n            side=order.side,\n            total_quantity=order.total_quantity,\n            remaining_quantity=order.total_quantity,\n            limit_price=order.limit_price,\n            start_time=start_time,\n            end_time=end_time,\n            duration_minutes=order.duration_minutes,\n            execution_strategy=order.execution_strategy,\n            slice_size=slice_size,\n            slice_interval_seconds=slice_interval,\n            total_slices=num_slices,\n            status="active",\n            started_at=start_time,\n            metadata=order.metadata or {}\n        )\n        \n        db.add(db_order)\n        db.commit()\n        db.refresh(db_order)\n        \n        for i in range(num_slices):\n            slice_time = start_time + timedelta(seconds=slice_interval * i)\n            adjusted_slice_size = slice_size\n            \n            slice_obj = OrderSlice(\n                order_id=db_order.order_id,\n                slice_number=i + 1,\n                quantity=adjusted_slice_size,\n                scheduled_time=slice_time,\n                status="pending"\n            )\n            db.add(slice_obj)\n        \n        db.commit()\n        logger.info(f"Created VWAP order: {db_order.order_id}")\n        \n        return {\n            "order_id": db_order.order_id,\n            "order_type": "vwap",\n            "symbol": db_order.symbol,\n            "side": db_order.side,\n            "total_quantity": db_order.total_quantity,\n            "num_slices": num_slices,\n            "start_time": db_order.start_time,\n            "end_time": db_order.end_time,\n            "status": db_order.status\n        }\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating VWAP order: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/orders/{order_id}")\nasync def get_order(order_id: str, db: Session = Depends(get_db)):\n    order = db.query(AdvancedOrder).filter(AdvancedOrder.order_id == order_id).first()\n    if not order:\n        raise HTTPException(status_code=404, detail="Order not found")\n    return order\n\n@app.get("/api/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    try:\n        total_orders = db.query(AdvancedOrder).count()\n        active_orders = db.query(AdvancedOrder).filter(\n            AdvancedOrder.status.in_(["active", "executing"])\n        ).count()\n        completed_orders = db.query(AdvancedOrder).filter(\n            AdvancedOrder.status == "completed"\n        ).count()\n        \n        return {\n            "total_orders": total_orders,\n            "active_orders": active_orders,\n            "completed_orders": completed_orders\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "advanced-trading"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8124)\n</create-file>\n</function_calls>\n</function_calls>'}