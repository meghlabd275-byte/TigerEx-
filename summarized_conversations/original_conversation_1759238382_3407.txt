{'role': 'assistant', 'content': '\n<function_calls>\n<full-file-rewrite file_path="backend/trading-bots-service/main.py">\nfrom fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime, timedelta\nimport asyncio\nimport json\nfrom enum import Enum\nimport uuid\nimport logging\nfrom sqlalchemy import create_engine, Column, String, Float, Integer, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport redis\nfrom collections import defaultdict\nimport numpy as np\nimport random\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title="Trading Bots Service", version="2.0.0")\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Database setup\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/trading_bots"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Redis setup for real-time data\nredis_client = redis.Redis(host=\'localhost\', port=6379, db=0, decode_responses=True)\n\n# WebSocket connection manager\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: Dict[str, WebSocket] = {}\n\n    async def connect(self, websocket: WebSocket, bot_id: str):\n        await websocket.accept()\n        self.active_connections[bot_id] = websocket\n        logger.info(f"WebSocket connected for bot {bot_id}")\n\n    def disconnect(self, bot_id: str):\n        if bot_id in self.active_connections:\n            del self.active_connections[bot_id]\n            logger.info(f"WebSocket disconnected for bot {bot_id}")\n\n    async def send_update(self, bot_id: str, message: dict):\n        if bot_id in self.active_connections:\n            try:\n                await self.active_connections[bot_id].send_json(message)\n            except Exception as e:\n                logger.error(f"Error sending update to bot {bot_id}: {e}")\n                self.disconnect(bot_id)\n\n    async def broadcast(self, message: dict):\n        for bot_id, connection in self.active_connections.items():\n            try:\n                await connection.send_json(message)\n            except Exception as e:\n                logger.error(f"Error broadcasting to bot {bot_id}: {e}")\n\nmanager = ConnectionManager()\n\n# Database Models\nclass BotDB(Base):\n    __tablename__ = "bots"\n    \n    id = Column(String, primary_key=True)\n    user_id = Column(String, nullable=False, index=True)\n    name = Column(String, nullable=False)\n    bot_type = Column(String, nullable=False)\n    trading_pair = Column(String, nullable=False)\n    status = Column(String, default="stopped")\n    config = Column(JSON, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    started_at = Column(DateTime, nullable=True)\n    stopped_at = Column(DateTime, nullable=True)\n\nclass BotPerformanceDB(Base):\n    __tablename__ = "bot_performance"\n    \n    id = Column(String, primary_key=True)\n    bot_id = Column(String, nullable=False, index=True)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    total_trades = Column(Integer, default=0)\n    winning_trades = Column(Integer, default=0)\n    losing_trades = Column(Integer, default=0)\n    total_profit = Column(Float, default=0.0)\n    total_loss = Column(Float, default=0.0)\n    roi = Column(Float, default=0.0)\n    sharpe_ratio = Column(Float, default=0.0)\n    max_drawdown = Column(Float, default=0.0)\n    win_rate = Column(Float, default=0.0)\n\nclass BotTradeDB(Base):\n    __tablename__ = "bot_trades"\n    \n    id = Column(String, primary_key=True)\n    bot_id = Column(String, nullable=False, index=True)\n    trade_type = Column(String, nullable=False)  # buy/sell\n    price = Column(Float, nullable=False)\n    amount = Column(Float, nullable=False)\n    total = Column(Float, nullable=False)\n    profit_loss = Column(Float, default=0.0)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    status = Column(String, default="completed")\n\nclass BotRiskMetricsDB(Base):\n    __tablename__ = "bot_risk_metrics"\n    \n    id = Column(String, primary_key=True)\n    bot_id = Column(String, nullable=False, index=True)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    position_size = Column(Float, default=0.0)\n    leverage = Column(Float, default=1.0)\n    stop_loss = Column(Float, nullable=True)\n    take_profit = Column(Float, nullable=True)\n    risk_score = Column(Float, default=0.0)\n    exposure = Column(Float, default=0.0)\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Enums\nclass BotType(str, Enum):\n    GRID = "grid"\n    DCA = "dca"\n    MARTINGALE = "martingale"\n    ARBITRAGE = "arbitrage"\n    MARKET_MAKING = "market_making"\n\nclass BotStatus(str, Enum):\n    RUNNING = "running"\n    STOPPED = "stopped"\n    PAUSED = "paused"\n    ERROR = "error"\n\n# Pydantic Models\nclass GridBotConfig(BaseModel):\n    grid_levels: int = Field(ge=2, le=50)\n    price_range_low: float = Field(gt=0)\n    price_range_high: float = Field(gt=0)\n    investment_amount: float = Field(gt=0)\n    profit_per_grid: float = Field(ge=0.1, le=10)\n\nclass DCABotConfig(BaseModel):\n    investment_amount: float = Field(gt=0)\n    interval_hours: int = Field(ge=1, le=168)\n    total_cycles: int = Field(ge=1, le=100)\n    price_drop_threshold: Optional[float] = Field(ge=0, le=50, default=None)\n\nclass MartingaleBotConfig(BaseModel):\n    initial_investment: float = Field(gt=0)\n    multiplier: float = Field(ge=1.5, le=5)\n    max_cycles: int = Field(ge=1, le=10)\n    take_profit_percentage: float = Field(ge=0.5, le=20)\n\nclass ArbitrageBotConfig(BaseModel):\n    exchanges: List[str] = Field(min_items=2)\n    min_profit_percentage: float = Field(ge=0.1, le=10)\n    max_position_size: float = Field(gt=0)\n\nclass MarketMakingBotConfig(BaseModel):\n    spread_percentage: float = Field(ge=0.1, le=5)\n    order_amount: float = Field(gt=0)\n    num_orders: int = Field(ge=1, le=20)\n    inventory_target: float = Field(gt=0)\n\nclass BotCreate(BaseModel):\n    name: str\n    bot_type: BotType\n    trading_pair: str\n    config: Dict[str, Any]\n\nclass BotUpdate(BaseModel):\n    name: Optional[str] = None\n    config: Optional[Dict[str, Any]] = None\n    status: Optional[BotStatus] = None\n\nclass BotResponse(BaseModel):\n    id: str\n    user_id: str\n    name: str\n    bot_type: str\n    trading_pair: str\n    status: str\n    config: Dict[str, Any]\n    created_at: datetime\n    updated_at: datetime\n    started_at: Optional[datetime] = None\n    stopped_at: Optional[datetime] = None\n\nclass PerformanceMetrics(BaseModel):\n    total_trades: int\n    winning_trades: int\n    losing_trades: int\n    total_profit: float\n    total_loss: float\n    net_profit: float\n    roi: float\n    win_rate: float\n    sharpe_ratio: float\n    max_drawdown: float\n    average_trade_duration: float\n\nclass RiskMetrics(BaseModel):\n    position_size: float\n    leverage: float\n    stop_loss: Optional[float]\n    take_profit: Optional[float]\n    risk_score: float\n    exposure: float\n    var_95: float  # Value at Risk 95%\n    expected_shortfall: float\n\n# Bot Execution Logic\nclass TradingBot:\n    def __init__(self, bot_id: str, user_id: str, bot_type: str, trading_pair: str, config: Dict, db: Session):\n        self.bot_id = bot_id\n        self.user_id = user_id\n        self.bot_type = bot_type\n        self.trading_pair = trading_pair\n        self.config = config\n        self.db = db\n        self.is_running = False\n        self.trades: List[Dict] = []\n        self.performance_data = {\n            "total_trades": 0,\n            "winning_trades": 0,\n            "losing_trades": 0,\n            "total_profit": 0.0,\n            "total_loss": 0.0\n        }\n\n    async def start(self):\n        self.is_running = True\n        logger.info(f"Starting bot {self.bot_id} of type {self.bot_type}")\n        \n        # Update bot status in database\n        bot = self.db.query(BotDB).filter(BotDB.id == self.bot_id).first()\n        if bot:\n            bot.status = "running"\n            bot.started_at = datetime.utcnow()\n            self.db.commit()\n        \n        # Start bot execution based on type\n        if self.bot_type == "grid":\n            await self.run_grid_bot()\n        elif self.bot_type == "dca":\n            await self.run_dca_bot()\n        elif self.bot_type == "martingale":\n            await self.run_martingale_bot()\n        elif self.bot_type == "arbitrage":\n            await self.run_arbitrage_bot()\n        elif self.bot_type == "market_making":\n            await self.run_market_making_bot()\n\n    async def stop(self):\n        self.is_running = False\n        logger.info(f"Stopping bot {self.bot_id}")\n        \n        # Update bot status in database\n        bot = self.db.query(BotDB).filter(BotDB.id == self.bot_id).first()\n        if bot:\n            bot.status = "stopped"\n            bot.stopped_at = datetime.utcnow()\n            self.db.commit()\n\n    async def run_grid_bot(self):\n        """Grid trading bot implementation"""\n        grid_levels = self.config.get("grid_levels", 10)\n        price_low = self.config.get("price_range_low", 30000)\n        price_high = self.config.get("price_range_high", 50000)\n        investment = self.config.get("investment_amount", 10000)\n        profit_per_grid = self.config.get("profit_per_grid", 0.5)\n        \n        grid_step = (price_high - price_low) / grid_levels\n        amount_per_grid = investment / grid_levels\n        \n        while self.is_running:\n            try:\n                # Simulate current price\n                current_price = random.uniform(price_low, price_high)\n                \n                # Place buy orders below current price\n                for i in range(grid_levels):\n                    buy_price = price_low + (i * grid_step)\n                    if buy_price < current_price:\n                        sell_price = buy_price * (1 + profit_per_grid / 100)\n                        \n                        # Execute trade\n                        trade = await self.execute_trade("buy", buy_price, amount_per_grid / buy_price)\n                        await asyncio.sleep(1)\n                        \n                        # Execute sell\n                        if sell_price <= current_price:\n                            sell_trade = await self.execute_trade("sell", sell_price, amount_per_grid / buy_price)\n                            profit = (sell_price - buy_price) * (amount_per_grid / buy_price)\n                            await self.update_performance(profit)\n                \n                # Send WebSocket update\n                await manager.send_update(self.bot_id, {\n                    "type": "grid_update",\n                    "current_price": current_price,\n                    "performance": self.performance_data\n                })\n                \n                await asyncio.sleep(10)  # Check every 10 seconds\n                \n            except Exception as e:\n                logger.error(f"Error in grid bot {self.bot_id}: {e}")\n                await asyncio.sleep(5)\n\n    async def run_dca_bot(self):\n        """Dollar Cost Averaging bot implementation"""\n        investment = self.config.get("investment_amount", 100)\n        interval_hours = self.config.get("interval_hours", 24)\n        total_cycles = self.config.get("total_cycles", 30)\n        \n        cycles_completed = 0\n        \n        while self.is_running and cycles_completed < total_cycles:\n            try:\n                # Simulate current price\n                current_price = random.uniform(30000, 50000)\n                \n                # Execute buy order\n                amount = investment / current_price\n                trade = await self.execute_trade("buy", current_price, amount)\n                \n                cycles_completed += 1\n                \n                # Send WebSocket update\n                await manager.send_update(self.bot_id, {\n                    "type": "dca_update",\n                    "cycles_completed": cycles_completed,\n                    "total_cycles": total_cycles,\n                    "current_price": current_price,\n                    "performance": self.performance_data\n                })\n                \n                # Wait for next interval\n                await asyncio.sleep(interval_hours * 3600)\n                \n            except Exception as e:\n                logger.error(f"Error in DCA bot {self.bot_id}: {e}")\n                await asyncio.sleep(60)\n\n    async def run_martingale_bot(self):\n        """Martingale bot implementation"""\n        initial_investment = self.config.get("initial_investment", 100)\n        multiplier = self.config.get("multiplier", 2.0)\n        max_cycles = self.config.get("max_cycles", 5)\n        take_profit_pct = self.config.get("take_profit_percentage", 5)\n        \n        current_investment = initial_investment\n        cycle = 0\n        entry_price = None\n        \n        while self.is_running:\n            try:\n                current_price = random.uniform(30000, 50000)\n                \n                if entry_price is None:\n                    # Initial entry\n                    amount = current_investment / current_price\n                    trade = await self.execute_trade("buy", current_price, amount)\n                    entry_price = current_price\n                    \n                else:\n                    # Check if we hit take profit\n                    if current_price >= entry_price * (1 + take_profit_pct / 100):\n                        # Take profit\n                        amount = current_investment / entry_price\n                        trade = await self.execute_trade("sell", current_price, amount)\n                        profit = (current_price - entry_price) * amount\n                        await self.update_performance(profit)\n                        \n                        # Reset\n                        current_investment = initial_investment\n                        cycle = 0\n                        entry_price = None\n                        \n                    # Check if we hit stop loss\n                    elif current_price <= entry_price * 0.95 and cycle < max_cycles:\n                        # Double down\n                        cycle += 1\n                        current_investment *= multiplier\n                        amount = current_investment / current_price\n                        trade = await self.execute_trade("buy", current_price, amount)\n                        entry_price = (entry_price + current_price) / 2  # Average entry\n                \n                await manager.send_update(self.bot_id, {\n                    "type": "martingale_update",\n                    "cycle": cycle,\n                    "current_investment": current_investment,\n                    "entry_price": entry_price,\n                    "current_price": current_price,\n                    "performance": self.performance_data\n                })\n                \n                await asyncio.sleep(5)\n                \n            except Exception as e:\n                logger.error(f"Error in Martingale bot {self.bot_id}: {e}")\n                await asyncio.sleep(5)\n\n    async def run_arbitrage_bot(self):\n        """Arbitrage bot implementation"""\n        exchanges = self.config.get("exchanges", ["binance", "coinbase"])\n        min_profit_pct = self.config.get("min_profit_percentage", 0.5)\n        max_position = self.config.get("max_position_size", 10000)\n        \n        while self.is_running:\n            try:\n                # Simulate prices on different exchanges\n                price_exchange1 = random.uniform(30000, 50000)\n                price_exchange2 = price_exchange1 * random.uniform(0.995, 1.005)\n                \n                # Calculate arbitrage opportunity\n                price_diff_pct = abs(price_exchange2 - price_exchange1) / price_exchange1 * 100\n                \n                if price_diff_pct >= min_profit_pct:\n                    # Execute arbitrage\n                    if price_exchange1 < price_exchange2:\n                        # Buy on exchange 1, sell on exchange 2\n                        amount = max_position / price_exchange1\n                        await self.execute_trade("buy", price_exchange1, amount)\n                        await self.execute_trade("sell", price_exchange2, amount)\n                        profit = (price_exchange2 - price_exchange1) * amount\n                        await self.update_performance(profit)\n                    else:\n                        # Buy on exchange 2, sell on exchange 1\n                        amount = max_position / price_exchange2\n                        await self.execute_trade("buy", price_exchange2, amount)\n                        await self.execute_trade("sell", price_exchange1, amount)\n                        profit = (price_exchange1 - price_exchange2) * amount\n                        await self.update_performance(profit)\n                \n                await manager.send_update(self.bot_id, {\n                    "type": "arbitrage_update",\n                    "price_exchange1": price_exchange1,\n                    "price_exchange2": price_exchange2,\n                    "price_diff_pct": price_diff_pct,\n                    "performance": self.performance_data\n                })\n                \n                await asyncio.sleep(2)\n                \n            except Exception as e:\n                logger.error(f"Error in Arbitrage bot {self.bot_id}: {e}")\n                await asyncio.sleep(5)\n\n    async def run_market_making_bot(self):\n        """Market making bot implementation"""\n        spread_pct = self.config.get("spread_percentage", 0.5)\n        order_amount = self.config.get("order_amount", 1000)\n        num_orders = self.config.get("num_orders", 5)\n        \n        while self.is_running:\n            try:\n                # Simulate mid price\n                mid_price = random.uniform(30000, 50000)\n                \n                # Place buy and sell orders around mid price\n                for i in range(num_orders):\n                    offset = (i + 1) * (spread_pct / 100) * mid_price\n                    \n                    buy_price = mid_price - offset\n                    sell_price = mid_price + offset\n                    \n                    amount = order_amount / mid_price\n                    \n                    # Simulate order fills\n                    if random.random() > 0.7:  # 30% chance of fill\n                        await self.execute_trade("buy", buy_price, amount)\n                        await asyncio.sleep(0.5)\n                        await self.execute_trade("sell", sell_price, amount)\n                        profit = (sell_price - buy_price) * amount\n                        await self.update_performance(profit)\n                \n                await manager.send_update(self.bot_id, {\n                    "type": "market_making_update",\n                    "mid_price": mid_price,\n                    "spread": spread_pct,\n                    "performance": self.performance_data\n                })\n                \n                await asyncio.sleep(5)\n                \n            except Exception as e:\n                logger.error(f"Error in Market Making bot {self.bot_id}: {e}")\n                await asyncio.sleep(5)\n\n    async def execute_trade(self, trade_type: str, price: float, amount: float):\n        """Execute a trade and record it"""\n        trade_id = str(uuid.uuid4())\n        total = price * amount\n        \n        trade = BotTradeDB(\n            id=trade_id,\n            bot_id=self.bot_id,\n            trade_type=trade_type,\n            price=price,\n            amount=amount,\n            total=total,\n            timestamp=datetime.utcnow(),\n            status="completed"\n        )\n        \n        self.db.add(trade)\n        self.db.commit()\n        \n        self.trades.append({\n            "id": trade_id,\n            "type": trade_type,\n            "price": price,\n            "amount": amount,\n            "total": total,\n            "timestamp": datetime.utcnow().isoformat()\n        })\n        \n        self.performance_data["total_trades"] += 1\n        \n        logger.info(f"Bot {self.bot_id} executed {trade_type} at {price} for {amount}")\n        \n        return trade\n\n    async def update_performance(self, profit: float):\n        """Update performance metrics"""\n        if profit > 0:\n            self.performance_data["winning_trades"] += 1\n            self.performance_data["total_profit"] += profit\n        else:\n            self.performance_data["losing_trades"] += 1\n            self.performance_data["total_loss"] += abs(profit)\n        \n        # Calculate metrics\n        total_trades = self.performance_data["total_trades"]\n        if total_trades > 0:\n            win_rate = self.performance_data["winning_trades"] / total_trades * 100\n            net_profit = self.performance_data["total_profit"] - self.performance_data["total_loss"]\n            \n            # Save to database\n            perf_id = str(uuid.uuid4())\n            performance = BotPerformanceDB(\n                id=perf_id,\n                bot_id=self.bot_id,\n                timestamp=datetime.utcnow(),\n                total_trades=total_trades,\n                winning_trades=self.performance_data["winning_trades"],\n                losing_trades=self.performance_data["losing_trades"],\n                total_profit=self.performance_data["total_profit"],\n                total_loss=self.performance_data["total_loss"],\n                roi=net_profit / 10000 * 100,  # Assuming 10000 initial investment\n                win_rate=win_rate\n            )\n            \n            self.db.add(performance)\n            self.db.commit()\n\n# Global bot instances\nactive_bots: Dict[str, TradingBot] = {}\n\n# API Endpoints\n@app.post("/bots", response_model=BotResponse)\nasync def create_bot(bot: BotCreate, user_id: str = "user123", db: Session = Depends(get_db)):\n    """Create a new trading bot"""\n    bot_id = str(uuid.uuid4())\n    \n    db_bot = BotDB(\n        id=bot_id,\n        user_id=user_id,\n        name=bot.name,\n        bot_type=bot.bot_type,\n        trading_pair=bot.trading_pair,\n        status="stopped",\n        config=bot.config,\n        created_at=datetime.utcnow(),\n        updated_at=datetime.utcnow()\n    )\n    \n    db.add(db_bot)\n    db.commit()\n    db.refresh(db_bot)\n    \n    logger.info(f"Created bot {bot_id} for user {user_id}")\n    \n    return BotResponse(\n        id=db_bot.id,\n        user_id=db_bot.user_id,\n        name=db_bot.name,\n        bot_type=db_bot.bot_type,\n        trading_pair=db_bot.trading_pair,\n        status=db_bot.status,\n        config=db_bot.config,\n        created_at=db_bot.created_at,\n        updated_at=db_bot.updated_at,\n        started_at=db_bot.started_at,\n        stopped_at=db_bot.stopped_at\n    )\n\n@app.get("/bots", response_model=List[BotResponse])\nasync def list_bots(user_id: str = "user123", db: Session = Depends(get_db)):\n    """List all bots for a user"""\n    bots = db.query(BotDB).filter(BotDB.user_id == user_id).all()\n    \n    return [BotResponse(\n        id=bot.id,\n        user_id=bot.user_id,\n        name=bot.name,\n        bot_type=bot.bot_type,\n        trading_pair=bot.trading_pair,\n        status=bot.status,\n        config=bot.config,\n        created_at=bot.created_at,\n        updated_at=bot.updated_at,\n        started_at=bot.started_at,\n        stopped_at=bot.stopped_at\n    ) for bot in bots]\n\n@app.get("/bots/{bot_id}", response_model=BotResponse)\nasync def get_bot(bot_id: str, db: Session = Depends(get_db)):\n    """Get a specific bot"""\n    bot = db.query(BotDB).filter(BotDB.id == bot_id).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    return BotResponse(\n        id=bot.id,\n        user_id=bot.user_id,\n        name=bot.name,\n        bot_type=bot.bot_type,\n        trading_pair=bot.trading_pair,\n        status=bot.status,\n        config=bot.config,\n        created_at=bot.created_at,\n        updated_at=bot.updated_at,\n        started_at=bot.started_at,\n        stopped_at=bot.stopped_at\n    )\n\n@app.post("/bots/{bot_id}/start")\nasync def start_bot(bot_id: str, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):\n    """Start a bot"""\n    bot = db.query(BotDB).filter(BotDB.id == bot_id).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    if bot_id in active_bots:\n        raise HTTPException(status_code=400, detail="Bot is already running")\n    \n    # Create bot instance\n    trading_bot = TradingBot(\n        bot_id=bot.id,\n        user_id=bot.user_id,\n        bot_type=bot.bot_type,\n        trading_pair=bot.trading_pair,\n        config=bot.config,\n        db=db\n    )\n    \n    active_bots[bot_id] = trading_bot\n    \n    # Start bot in background\n    background_tasks.add_task(trading_bot.start)\n    \n    return {"message": "Bot started successfully", "bot_id": bot_id}\n\n@app.post("/bots/{bot_id}/stop")\nasync def stop_bot(bot_id: str, db: Session = Depends(get_db)):\n    """Stop a bot"""\n    if bot_id not in active_bots:\n        raise HTTPException(status_code=400, detail="Bot is not running")\n    \n    bot = active_bots[bot_id]\n    await bot.stop()\n    \n    del active_bots[bot_id]\n    \n    return {"message": "Bot stopped successfully", "bot_id": bot_id}\n\n@app.delete("/bots/{bot_id}")\nasync def delete_bot(bot_id: str, db: Session = Depends(get_db)):\n    """Delete a bot"""\n    # Stop bot if running\n    if bot_id in active_bots:\n        await stop_bot(bot_id, db)\n    \n    bot = db.query(BotDB).filter(BotDB.id == bot_id).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    # Delete related data\n    db.query(BotPerformanceDB).filter(BotPerformanceDB.bot_id == bot_id).delete()\n    db.query(BotTradeDB).filter(BotTradeDB.bot_id == bot_id).delete()\n    db.query(BotRiskMetricsDB).filter(BotRiskMetricsDB.bot_id == bot_id).delete()\n    \n    db.delete(bot)\n    db.commit()\n    \n    return {"message": "Bot deleted successfully", "bot_id": bot_id}\n\n@app.get("/bots/{bot_id}/performance", response_model=PerformanceMetrics)\nasync def get_bot_performance(bot_id: str, db: Session = Depends(get_db)):\n    """Get bot performance metrics"""\n    performance = db.query(BotPerformanceDB).filter(\n        BotPerformanceDB.bot_id == bot_id\n    ).order_by(BotPerformanceDB.timestamp.desc()).first()\n    \n    if not performance:\n        return PerformanceMetrics(\n            total_trades=0,\n            winning_trades=0,\n            losing_trades=0,\n            total_profit=0.0,\n            total_loss=0.0,\n            net_profit=0.0,\n            roi=0.0,\n            win_rate=0.0,\n            sharpe_ratio=0.0,\n            max_drawdown=0.0,\n            average_trade_duration=0.0\n        )\n    \n    net_profit = performance.total_profit - performance.total_loss\n    \n    return PerformanceMetrics(\n        total_trades=performance.total_trades,\n        winning_trades=performance.winning_trades,\n        losing_trades=performance.losing_trades,\n        total_profit=performance.total_profit,\n        total_loss=performance.total_loss,\n        net_profit=net_profit,\n        roi=performance.roi,\n        win_rate=performance.win_rate,\n        sharpe_ratio=performance.sharpe_ratio,\n        max_drawdown=performance.max_drawdown,\n        average_trade_duration=0.0\n    )\n\n@app.get("/bots/{bot_id}/trades")\nasync def get_bot_trades(bot_id: str, limit: int = 100, db: Session = Depends(get_db)):\n    """Get bot trade history"""\n    trades = db.query(BotTradeDB).filter(\n        BotTradeDB.bot_id == bot_id\n    ).order_by(BotTradeDB.timestamp.desc()).limit(limit).all()\n    \n    return [{\n        "id": trade.id,\n        "bot_id": trade.bot_id,\n        "trade_type": trade.trade_type,\n        "price": trade.price,\n        "amount": trade.amount,\n        "total": trade.total,\n        "profit_loss": trade.profit_loss,\n        "timestamp": trade.timestamp.isoformat(),\n        "status": trade.status\n    } for trade in trades]\n\n@app.get("/bots/{bot_id}/risk", response_model=RiskMetrics)\nasync def get_bot_risk_metrics(bot_id: str, db: Session = Depends(get_db)):\n    """Get bot risk metrics"""\n    risk = db.query(BotRiskMetricsDB).filter(\n        BotRiskMetricsDB.bot_id == bot_id\n    ).order_by(BotRiskMetricsDB.timestamp.desc()).first()\n    \n    if not risk:\n        return RiskMetrics(\n            position_size=0.0,\n            leverage=1.0,\n            stop_loss=None,\n            take_profit=None,\n            risk_score=0.0,\n            exposure=0.0,\n            var_95=0.0,\n            expected_shortfall=0.0\n        )\n    \n    return RiskMetrics(\n        position_size=risk.position_size,\n        leverage=risk.leverage,\n        stop_loss=risk.stop_loss,\n        take_profit=risk.take_profit,\n        risk_score=risk.risk_score,\n        exposure=risk.exposure,\n        var_95=0.0,\n        expected_shortfall=0.0\n    )\n\n@app.websocket("/ws/{bot_id}")\nasync def websocket_endpoint(websocket: WebSocket, bot_id: str):\n    """WebSocket endpoint for real-time bot updates"""\n    await manager.connect(websocket, bot_id)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            # Handle incoming messages if needed\n            await asyncio.sleep(0.1)\n    except WebSocketDisconnect:\n        manager.disconnect(bot_id)\n\n@app.get("/health")\nasync def health_check():\n    """Health check endpoint"""\n    return {\n        "status": "healthy",\n        "active_bots": len(active_bots),\n        "timestamp": datetime.utcnow().isoformat()\n    }\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8001)\n</full-file-rewrite>\n</function_calls>\n</function_calls>'}