{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/copy-trading-admin/src/main.py">\n"""\nTigerEx Copy Trading Admin Panel\nManages copy trading traders, followers, and performance tracking\nPort: 8116\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends, Query\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Database setup\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_copy_trading"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass TraderStatus(str, Enum):\n    ACTIVE = "active"\n    INACTIVE = "inactive"\n    SUSPENDED = "suspended"\n    UNDER_REVIEW = "under_review"\n\nclass TraderTier(str, Enum):\n    BRONZE = "bronze"\n    SILVER = "silver"\n    GOLD = "gold"\n    PLATINUM = "platinum"\n    DIAMOND = "diamond"\n\nclass CopyMode(str, Enum):\n    FIXED_AMOUNT = "fixed_amount"\n    FIXED_RATIO = "fixed_ratio"\n    PROPORTIONAL = "proportional"\n\nclass RiskLevel(str, Enum):\n    LOW = "low"\n    MEDIUM = "medium"\n    HIGH = "high"\n    VERY_HIGH = "very_high"\n\n# Database Models\nclass MasterTrader(Base):\n    __tablename__ = "master_traders"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, unique=True, index=True)\n    username = Column(String, unique=True, index=True)\n    display_name = Column(String)\n    bio = Column(Text)\n    avatar_url = Column(String)\n    status = Column(String, default="active")\n    tier = Column(String, default="bronze")\n    risk_level = Column(String)\n    \n    # Performance metrics\n    total_followers = Column(Integer, default=0)\n    total_aum = Column(Float, default=0.0)  # Assets Under Management\n    roi_30d = Column(Float, default=0.0)\n    roi_90d = Column(Float, default=0.0)\n    roi_1y = Column(Float, default=0.0)\n    roi_all_time = Column(Float, default=0.0)\n    win_rate = Column(Float, default=0.0)\n    sharpe_ratio = Column(Float, default=0.0)\n    max_drawdown = Column(Float, default=0.0)\n    avg_trade_duration = Column(Integer, default=0)  # in hours\n    total_trades = Column(Integer, default=0)\n    profitable_trades = Column(Integer, default=0)\n    \n    # Trading stats\n    total_profit = Column(Float, default=0.0)\n    total_loss = Column(Float, default=0.0)\n    avg_profit_per_trade = Column(Float, default=0.0)\n    avg_loss_per_trade = Column(Float, default=0.0)\n    largest_win = Column(Float, default=0.0)\n    largest_loss = Column(Float, default=0.0)\n    \n    # Settings\n    profit_sharing = Column(Float, default=10.0)  # percentage\n    min_copy_amount = Column(Float, default=100.0)\n    max_followers = Column(Integer, default=1000)\n    allow_new_followers = Column(Boolean, default=True)\n    \n    # Verification\n    is_verified = Column(Boolean, default=False)\n    kyc_verified = Column(Boolean, default=False)\n    \n    # Timestamps\n    joined_date = Column(DateTime, default=datetime.utcnow)\n    last_active = Column(DateTime, default=datetime.utcnow)\n    last_trade = Column(DateTime, nullable=True)\n    \n    metadata = Column(JSON)\n\nclass Follower(Base):\n    __tablename__ = "followers"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, index=True)\n    trader_id = Column(Integer, index=True)\n    \n    # Copy settings\n    copy_mode = Column(String, default="fixed_amount")\n    copy_amount = Column(Float)  # for fixed_amount mode\n    copy_ratio = Column(Float)  # for fixed_ratio mode (e.g., 0.1 = 10%)\n    \n    # Risk management\n    stop_loss_percentage = Column(Float, nullable=True)\n    take_profit_percentage = Column(Float, nullable=True)\n    max_open_positions = Column(Integer, default=10)\n    \n    # Performance\n    total_invested = Column(Float, default=0.0)\n    current_value = Column(Float, default=0.0)\n    total_profit_loss = Column(Float, default=0.0)\n    roi = Column(Float, default=0.0)\n    \n    # Status\n    is_active = Column(Boolean, default=True)\n    auto_copy = Column(Boolean, default=True)\n    \n    # Timestamps\n    start_date = Column(DateTime, default=datetime.utcnow)\n    end_date = Column(DateTime, nullable=True)\n    \n    metadata = Column(JSON)\n\nclass CopyTrade(Base):\n    __tablename__ = "copy_trades"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    trader_id = Column(Integer, index=True)\n    follower_id = Column(Integer, index=True)\n    master_trade_id = Column(Integer, index=True)\n    \n    # Trade details\n    symbol = Column(String, index=True)\n    side = Column(String)  # buy, sell\n    order_type = Column(String)  # market, limit\n    quantity = Column(Float)\n    entry_price = Column(Float)\n    exit_price = Column(Float, nullable=True)\n    \n    # P&L\n    profit_loss = Column(Float, default=0.0)\n    profit_loss_percentage = Column(Float, default=0.0)\n    \n    # Status\n    status = Column(String, default="open")  # open, closed, cancelled\n    \n    # Timestamps\n    opened_at = Column(DateTime, default=datetime.utcnow)\n    closed_at = Column(DateTime, nullable=True)\n    \n    metadata = Column(JSON)\n\nclass TraderPerformance(Base):\n    __tablename__ = "trader_performance"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    trader_id = Column(Integer, index=True)\n    date = Column(DateTime, index=True)\n    \n    # Daily metrics\n    daily_return = Column(Float)\n    cumulative_return = Column(Float)\n    trades_count = Column(Integer)\n    win_rate = Column(Float)\n    sharpe_ratio = Column(Float)\n    max_drawdown = Column(Float)\n    \n    # Portfolio\n    portfolio_value = Column(Float)\n    aum = Column(Float)\n    followers_count = Column(Integer)\n    \n    metadata = Column(JSON)\n\nclass TraderRanking(Base):\n    __tablename__ = "trader_rankings"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    trader_id = Column(Integer, unique=True, index=True)\n    \n    # Rankings\n    overall_rank = Column(Integer)\n    roi_rank = Column(Integer)\n    followers_rank = Column(Integer)\n    aum_rank = Column(Integer)\n    win_rate_rank = Column(Integer)\n    \n    # Scores\n    overall_score = Column(Float)\n    consistency_score = Column(Float)\n    risk_score = Column(Float)\n    \n    updated_at = Column(DateTime, default=datetime.utcnow)\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass MasterTraderCreate(BaseModel):\n    user_id: int\n    username: str\n    display_name: str\n    bio: str\n    risk_level: RiskLevel\n    profit_sharing: float = Field(ge=0, le=50, default=10.0)\n    min_copy_amount: float = Field(gt=0, default=100.0)\n    max_followers: int = Field(gt=0, default=1000)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass MasterTraderUpdate(BaseModel):\n    display_name: Optional[str] = None\n    bio: Optional[str] = None\n    avatar_url: Optional[str] = None\n    status: Optional[TraderStatus] = None\n    tier: Optional[TraderTier] = None\n    risk_level: Optional[RiskLevel] = None\n    profit_sharing: Optional[float] = None\n    min_copy_amount: Optional[float] = None\n    max_followers: Optional[int] = None\n    allow_new_followers: Optional[bool] = None\n    is_verified: Optional[bool] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass FollowerCreate(BaseModel):\n    user_id: int\n    trader_id: int\n    copy_mode: CopyMode\n    copy_amount: Optional[float] = None\n    copy_ratio: Optional[float] = None\n    stop_loss_percentage: Optional[float] = None\n    take_profit_percentage: Optional[float] = None\n    max_open_positions: int = Field(gt=0, default=10)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass FollowerUpdate(BaseModel):\n    copy_mode: Optional[CopyMode] = None\n    copy_amount: Optional[float] = None\n    copy_ratio: Optional[float] = None\n    stop_loss_percentage: Optional[float] = None\n    take_profit_percentage: Optional[float] = None\n    max_open_positions: Optional[int] = None\n    is_active: Optional[bool] = None\n    auto_copy: Optional[bool] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n# FastAPI app\napp = FastAPI(\n    title="TigerEx Copy Trading Admin API",\n    description="Admin panel for managing copy trading traders and followers",\n    version="1.0.0"\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# ==================== MASTER TRADER ENDPOINTS ====================\n\n@app.post("/api/admin/traders", status_code=201)\nasync def create_trader(trader: MasterTraderCreate, db: Session = Depends(get_db)):\n    """Create a new master trader"""\n    try:\n        # Check if user is already a trader\n        existing = db.query(MasterTrader).filter(MasterTrader.user_id == trader.user_id).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="User is already a master trader")\n        \n        # Check if username is taken\n        username_taken = db.query(MasterTrader).filter(MasterTrader.username == trader.username).first()\n        if username_taken:\n            raise HTTPException(status_code=400, detail="Username already taken")\n        \n        db_trader = MasterTrader(**trader.dict())\n        db.add(db_trader)\n        db.commit()\n        db.refresh(db_trader)\n        \n        logger.info(f"Created master trader: {trader.username}")\n        return db_trader\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating trader: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/traders")\nasync def get_traders(\n    skip: int = 0,\n    limit: int = 100,\n    status: Optional[TraderStatus] = None,\n    tier: Optional[TraderTier] = None,\n    risk_level: Optional[RiskLevel] = None,\n    is_verified: Optional[bool] = None,\n    min_followers: Optional[int] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all master traders with filters"""\n    try:\n        query = db.query(MasterTrader)\n        \n        if status:\n            query = query.filter(MasterTrader.status == status)\n        if tier:\n            query = query.filter(MasterTrader.tier == tier)\n        if risk_level:\n            query = query.filter(MasterTrader.risk_level == risk_level)\n        if is_verified is not None:\n            query = query.filter(MasterTrader.is_verified == is_verified)\n        if min_followers:\n            query = query.filter(MasterTrader.total_followers >= min_followers)\n        \n        total = query.count()\n        traders = query.order_by(MasterTrader.total_aum.desc()).offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "traders": traders\n        }\n    except Exception as e:\n        logger.error(f"Error fetching traders: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/traders/{trader_id}")\nasync def get_trader(trader_id: int, db: Session = Depends(get_db)):\n    """Get a specific master trader"""\n    trader = db.query(MasterTrader).filter(MasterTrader.id == trader_id).first()\n    if not trader:\n        raise HTTPException(status_code=404, detail="Trader not found")\n    return trader\n\n@app.put("/api/admin/traders/{trader_id}")\nasync def update_trader(\n    trader_id: int,\n    trader_update: MasterTraderUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a master trader"""\n    try:\n        trader = db.query(MasterTrader).filter(MasterTrader.id == trader_id).first()\n        if not trader:\n            raise HTTPException(status_code=404, detail="Trader not found")\n        \n        update_data = trader_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(trader, field, value)\n        \n        trader.last_active = datetime.utcnow()\n        db.commit()\n        db.refresh(trader)\n        \n        logger.info(f"Updated trader: {trader_id}")\n        return trader\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating trader: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/admin/traders/{trader_id}/verify")\nasync def verify_trader(trader_id: int, db: Session = Depends(get_db)):\n    """Verify a master trader"""\n    try:\n        trader = db.query(MasterTrader).filter(MasterTrader.id == trader_id).first()\n        if not trader:\n            raise HTTPException(status_code=404, detail="Trader not found")\n        \n        trader.is_verified = True\n        trader.kyc_verified = True\n        db.commit()\n        \n        logger.info(f"Verified trader: {trader_id}")\n        return {"message": "Trader verified successfully"}\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error verifying trader: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/admin/traders/{trader_id}/suspend")\nasync def suspend_trader(trader_id: int, reason: str, db: Session = Depends(get_db)):\n    """Suspend a master trader"""\n    try:\n        trader = db.query(MasterTrader).filter(MasterTrader.id == trader_id).first()\n        if not trader:\n            raise HTTPException(status_code=404, detail="Trader not found")\n        \n        trader.status = "suspended"\n        trader.allow_new_followers = False\n        \n        # Store suspension reason in metadata\n        if not trader.metadata:\n            trader.metadata = {}\n        trader.metadata["suspension_reason"] = reason\n        trader.metadata["suspended_at"] = datetime.utcnow().isoformat()\n        \n        db.commit()\n        \n        logger.info(f"Suspended trader: {trader_id}")\n        return {"message": "Trader suspended successfully"}\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error suspending trader: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== FOLLOWER ENDPOINTS ====================\n\n@app.post("/api/admin/followers", status_code=201)\nasync def create_follower(follower: FollowerCreate, db: Session = Depends(get_db)):\n    """Create a new follower relationship"""\n    try:\n        # Verify trader exists\n        trader = db.query(MasterTrader).filter(MasterTrader.id == follower.trader_id).first()\n        if not trader:\n            raise HTTPException(status_code=404, detail="Trader not found")\n        \n        # Check if trader accepts new followers\n        if not trader.allow_new_followers:\n            raise HTTPException(status_code=400, detail="Trader not accepting new followers")\n        \n        # Check if max followers reached\n        if trader.total_followers >= trader.max_followers:\n            raise HTTPException(status_code=400, detail="Trader has reached maximum followers")\n        \n        # Check if user is already following this trader\n        existing = db.query(Follower).filter(\n            Follower.user_id == follower.user_id,\n            Follower.trader_id == follower.trader_id,\n            Follower.is_active == True\n        ).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="User is already following this trader")\n        \n        # Validate copy settings\n        if follower.copy_mode == "fixed_amount" and not follower.copy_amount:\n            raise HTTPException(status_code=400, detail="Copy amount required for fixed_amount mode")\n        if follower.copy_mode == "fixed_ratio" and not follower.copy_ratio:\n            raise HTTPException(status_code=400, detail="Copy ratio required for fixed_ratio mode")\n        \n        # Check minimum copy amount\n        if follower.copy_amount and follower.copy_amount < trader.min_copy_amount:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Minimum copy amount is {trader.min_copy_amount}"\n            )\n        \n        db_follower = Follower(**follower.dict())\n        db.add(db_follower)\n        \n        # Update trader stats\n        trader.total_followers += 1\n        if follower.copy_amount:\n            trader.total_aum += follower.copy_amount\n        \n        db.commit()\n        db.refresh(db_follower)\n        \n        logger.info(f"Created follower relationship: user {follower.user_id} -> trader {follower.trader_id}")\n        return db_follower\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating follower: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/followers")\nasync def get_followers(\n    skip: int = 0,\n    limit: int = 100,\n    user_id: Optional[int] = None,\n    trader_id: Optional[int] = None,\n    is_active: Optional[bool] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all followers with filters"""\n    try:\n        query = db.query(Follower)\n        \n        if user_id:\n            query = query.filter(Follower.user_id == user_id)\n        if trader_id:\n            query = query.filter(Follower.trader_id == trader_id)\n        if is_active is not None:\n            query = query.filter(Follower.is_active == is_active)\n        \n        total = query.count()\n        followers = query.offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "followers": followers\n        }\n    except Exception as e:\n        logger.error(f"Error fetching followers: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.put("/api/admin/followers/{follower_id}")\nasync def update_follower(\n    follower_id: int,\n    follower_update: FollowerUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a follower relationship"""\n    try:\n        follower = db.query(Follower).filter(Follower.id == follower_id).first()\n        if not follower:\n            raise HTTPException(status_code=404, detail="Follower not found")\n        \n        update_data = follower_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(follower, field, value)\n        \n        db.commit()\n        db.refresh(follower)\n        \n        logger.info(f"Updated follower: {follower_id}")\n        return follower\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating follower: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.delete("/api/admin/followers/{follower_id}")\nasync def delete_follower(follower_id: int, db: Session = Depends(get_db)):\n    """Stop following a trader"""\n    try:\n        follower = db.query(Follower).filter(Follower.id == follower_id).first()\n        if not follower:\n            raise HTTPException(status_code=404, detail="Follower not found")\n        \n        follower.is_active = False\n        follower.end_date = datetime.utcnow()\n        \n        # Update trader stats\n        trader = db.query(MasterTrader).filter(MasterTrader.id == follower.trader_id).first()\n        if trader:\n            trader.total_followers -= 1\n            if follower.copy_amount:\n                trader.total_aum -= follower.copy_amount\n        \n        db.commit()\n        \n        logger.info(f"Stopped following: {follower_id}")\n        return {"message": "Stopped following trader successfully"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error deleting follower: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== COPY TRADE ENDPOINTS ====================\n\n@app.get("/api/admin/copy-trades")\nasync def get_copy_trades(\n    skip: int = 0,\n    limit: int = 100,\n    trader_id: Optional[int] = None,\n    follower_id: Optional[int] = None,\n    symbol: Optional[str] = None,\n    status: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all copy trades with filters"""\n    try:\n        query = db.query(CopyTrade)\n        \n        if trader_id:\n            query = query.filter(CopyTrade.trader_id == trader_id)\n        if follower_id:\n            query = query.filter(CopyTrade.follower_id == follower_id)\n        if symbol:\n            query = query.filter(CopyTrade.symbol == symbol)\n        if status:\n            query = query.filter(CopyTrade.status == status)\n        \n        total = query.count()\n        trades = query.order_by(CopyTrade.opened_at.desc()).offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "trades": trades\n        }\n    except Exception as e:\n        logger.error(f"Error fetching copy trades: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== ANALYTICS ENDPOINTS ====================\n\n@app.get("/api/admin/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get overall copy trading analytics"""\n    try:\n        total_traders = db.query(MasterTrader).count()\n        active_traders = db.query(MasterTrader).filter(MasterTrader.status == "active").count()\n        verified_traders = db.query(MasterTrader).filter(MasterTrader.is_verified == True).count()\n        total_followers = db.query(Follower).filter(Follower.is_active == True).count()\n        total_aum = db.query(MasterTrader).with_entities(\n            db.func.sum(MasterTrader.total_aum)\n        ).scalar() or 0.0\n        \n        # Recent trades\n        recent_trades = db.query(CopyTrade).filter(\n            CopyTrade.opened_at >= datetime.utcnow() - timedelta(days=7)\n        ).count()\n        \n        return {\n            "total_traders": total_traders,\n            "active_traders": active_traders,\n            "verified_traders": verified_traders,\n            "total_followers": total_followers,\n            "total_aum": total_aum,\n            "recent_trades_7d": recent_trades\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/leaderboard")\nasync def get_leaderboard(\n    metric: str = "roi",\n    period: str = "30d",\n    limit: int = 100,\n    db: Session = Depends(get_db)\n):\n    """Get trader leaderboard"""\n    try:\n        query = db.query(MasterTrader).filter(MasterTrader.status == "active")\n        \n        # Sort by metric\n        if metric == "roi":\n            if period == "30d":\n                query = query.order_by(MasterTrader.roi_30d.desc())\n            elif period == "90d":\n                query = query.order_by(MasterTrader.roi_90d.desc())\n            elif period == "1y":\n                query = query.order_by(MasterTrader.roi_1y.desc())\n            else:\n                query = query.order_by(MasterTrader.roi_all_time.desc())\n        elif metric == "followers":\n            query = query.order_by(MasterTrader.total_followers.desc())\n        elif metric == "aum":\n            query = query.order_by(MasterTrader.total_aum.desc())\n        elif metric == "win_rate":\n            query = query.order_by(MasterTrader.win_rate.desc())\n        \n        traders = query.limit(limit).all()\n        \n        return traders\n    except Exception as e:\n        logger.error(f"Error fetching leaderboard: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/trader-performance/{trader_id}")\nasync def get_trader_performance(\n    trader_id: int,\n    days: int = 30,\n    db: Session = Depends(get_db)\n):\n    """Get trader performance history"""\n    try:\n        start_date = datetime.utcnow() - timedelta(days=days)\n        \n        performance = db.query(TraderPerformance).filter(\n            TraderPerformance.trader_id == trader_id,\n            TraderPerformance.date >= start_date\n        ).order_by(TraderPerformance.date).all()\n        \n        return performance\n    except Exception as e:\n        logger.error(f"Error fetching trader performance: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Health check\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "copy-trading-admin"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8116)\n</create-file>\n</function_calls>'}