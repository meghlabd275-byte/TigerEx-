{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/staking-service/main.py">\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport uuid\nimport logging\nfrom sqlalchemy import create_engine, Column, String, Float, Integer, DateTime, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport asyncio\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title="Staking Service", version="1.0.0")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/staking"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Database Models\nclass StakingProductDB(Base):\n    __tablename__ = "staking_products"\n    \n    id = Column(String, primary_key=True)\n    asset = Column(String, nullable=False)\n    product_type = Column(String, nullable=False)  # flexible, locked\n    duration_days = Column(Integer, nullable=True)\n    apy = Column(Float, nullable=False)\n    min_amount = Column(Float, default=0.0)\n    max_amount = Column(Float, nullable=True)\n    total_staked = Column(Float, default=0.0)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass StakingPositionDB(Base):\n    __tablename__ = "staking_positions"\n    \n    id = Column(String, primary_key=True)\n    user_id = Column(String, nullable=False, index=True)\n    product_id = Column(String, nullable=False)\n    asset = Column(String, nullable=False)\n    amount = Column(Float, nullable=False)\n    apy = Column(Float, nullable=False)\n    product_type = Column(String, nullable=False)\n    duration_days = Column(Integer, nullable=True)\n    start_date = Column(DateTime, default=datetime.utcnow)\n    end_date = Column(DateTime, nullable=True)\n    status = Column(String, default="active")  # active, completed, cancelled\n    total_rewards = Column(Float, default=0.0)\n    last_reward_date = Column(DateTime, default=datetime.utcnow)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass StakingRewardDB(Base):\n    __tablename__ = "staking_rewards"\n    \n    id = Column(String, primary_key=True)\n    position_id = Column(String, nullable=False, index=True)\n    user_id = Column(String, nullable=False, index=True)\n    asset = Column(String, nullable=False)\n    amount = Column(Float, nullable=False)\n    reward_date = Column(DateTime, default=datetime.utcnow)\n    status = Column(String, default="pending")  # pending, distributed\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Pydantic Models\nclass ProductType(str, Enum):\n    FLEXIBLE = "flexible"\n    LOCKED = "locked"\n\nclass StakingProductCreate(BaseModel):\n    asset: str\n    product_type: ProductType\n    duration_days: Optional[int] = None\n    apy: float = Field(gt=0, le=100)\n    min_amount: float = Field(ge=0)\n    max_amount: Optional[float] = None\n\nclass StakingProductResponse(BaseModel):\n    id: str\n    asset: str\n    product_type: str\n    duration_days: Optional[int]\n    apy: float\n    min_amount: float\n    max_amount: Optional[float]\n    total_staked: float\n    is_active: bool\n    created_at: datetime\n\nclass StakeRequest(BaseModel):\n    product_id: str\n    amount: float = Field(gt=0)\n\nclass StakingPositionResponse(BaseModel):\n    id: str\n    user_id: str\n    product_id: str\n    asset: str\n    amount: float\n    apy: float\n    product_type: str\n    duration_days: Optional[int]\n    start_date: datetime\n    end_date: Optional[datetime]\n    status: str\n    total_rewards: float\n    estimated_daily_reward: float\n\nclass RewardResponse(BaseModel):\n    id: str\n    position_id: str\n    user_id: str\n    asset: str\n    amount: float\n    reward_date: datetime\n    status: str\n\n# Reward calculation background task\nasync def calculate_and_distribute_rewards(db: Session):\n    """Background task to calculate and distribute staking rewards"""\n    while True:\n        try:\n            # Get all active positions\n            positions = db.query(StakingPositionDB).filter(\n                StakingPositionDB.status == "active"\n            ).all()\n            \n            for position in positions:\n                # Calculate daily reward\n                daily_reward = (position.amount * position.apy / 100) / 365\n                \n                # Check if 24 hours passed since last reward\n                time_since_last = datetime.utcnow() - position.last_reward_date\n                if time_since_last >= timedelta(hours=24):\n                    # Create reward record\n                    reward_id = str(uuid.uuid4())\n                    reward = StakingRewardDB(\n                        id=reward_id,\n                        position_id=position.id,\n                        user_id=position.user_id,\n                        asset=position.asset,\n                        amount=daily_reward,\n                        reward_date=datetime.utcnow(),\n                        status="distributed"\n                    )\n                    \n                    db.add(reward)\n                    \n                    # Update position\n                    position.total_rewards += daily_reward\n                    position.last_reward_date = datetime.utcnow()\n                    \n                    # Check if locked staking period ended\n                    if position.product_type == "locked" and position.end_date:\n                        if datetime.utcnow() >= position.end_date:\n                            position.status = "completed"\n                    \n                    db.commit()\n                    logger.info(f"Distributed reward {daily_reward} {position.asset} to position {position.id}")\n            \n            await asyncio.sleep(3600)  # Check every hour\n            \n        except Exception as e:\n            logger.error(f"Error in reward distribution: {e}")\n            await asyncio.sleep(60)\n\n# API Endpoints\n@app.post("/products", response_model=StakingProductResponse)\nasync def create_product(product: StakingProductCreate, db: Session = Depends(get_db)):\n    """Create a staking product"""\n    product_id = str(uuid.uuid4())\n    \n    db_product = StakingProductDB(\n        id=product_id,\n        asset=product.asset,\n        product_type=product.product_type,\n        duration_days=product.duration_days,\n        apy=product.apy,\n        min_amount=product.min_amount,\n        max_amount=product.max_amount,\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(db_product)\n    db.commit()\n    db.refresh(db_product)\n    \n    return StakingProductResponse(\n        id=db_product.id,\n        asset=db_product.asset,\n        product_type=db_product.product_type,\n        duration_days=db_product.duration_days,\n        apy=db_product.apy,\n        min_amount=db_product.min_amount,\n        max_amount=db_product.max_amount,\n        total_staked=db_product.total_staked,\n        is_active=db_product.is_active,\n        created_at=db_product.created_at\n    )\n\n@app.get("/products", response_model=List[StakingProductResponse])\nasync def list_products(asset: Optional[str] = None, product_type: Optional[str] = None, db: Session = Depends(get_db)):\n    """List all staking products"""\n    query = db.query(StakingProductDB).filter(StakingProductDB.is_active == True)\n    \n    if asset:\n        query = query.filter(StakingProductDB.asset == asset)\n    if product_type:\n        query = query.filter(StakingProductDB.product_type == product_type)\n    \n    products = query.all()\n    \n    return [StakingProductResponse(\n        id=p.id,\n        asset=p.asset,\n        product_type=p.product_type,\n        duration_days=p.duration_days,\n        apy=p.apy,\n        min_amount=p.min_amount,\n        max_amount=p.max_amount,\n        total_staked=p.total_staked,\n        is_active=p.is_active,\n        created_at=p.created_at\n    ) for p in products]\n\n@app.post("/stake", response_model=StakingPositionResponse)\nasync def stake_asset(stake: StakeRequest, user_id: str = "user123", db: Session = Depends(get_db)):\n    """Stake assets"""\n    product = db.query(StakingProductDB).filter(StakingProductDB.id == stake.product_id).first()\n    if not product:\n        raise HTTPException(status_code=404, detail="Product not found")\n    \n    if not product.is_active:\n        raise HTTPException(status_code=400, detail="Product is not active")\n    \n    if stake.amount < product.min_amount:\n        raise HTTPException(status_code=400, detail=f"Minimum stake amount is {product.min_amount}")\n    \n    if product.max_amount and stake.amount > product.max_amount:\n        raise HTTPException(status_code=400, detail=f"Maximum stake amount is {product.max_amount}")\n    \n    position_id = str(uuid.uuid4())\n    \n    # Calculate end date for locked staking\n    end_date = None\n    if product.product_type == "locked" and product.duration_days:\n        end_date = datetime.utcnow() + timedelta(days=product.duration_days)\n    \n    position = StakingPositionDB(\n        id=position_id,\n        user_id=user_id,\n        product_id=product.id,\n        asset=product.asset,\n        amount=stake.amount,\n        apy=product.apy,\n        product_type=product.product_type,\n        duration_days=product.duration_days,\n        start_date=datetime.utcnow(),\n        end_date=end_date,\n        status="active",\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(position)\n    \n    # Update product total staked\n    product.total_staked += stake.amount\n    \n    db.commit()\n    db.refresh(position)\n    \n    daily_reward = (stake.amount * product.apy / 100) / 365\n    \n    return StakingPositionResponse(\n        id=position.id,\n        user_id=position.user_id,\n        product_id=position.product_id,\n        asset=position.asset,\n        amount=position.amount,\n        apy=position.apy,\n        product_type=position.product_type,\n        duration_days=position.duration_days,\n        start_date=position.start_date,\n        end_date=position.end_date,\n        status=position.status,\n        total_rewards=position.total_rewards,\n        estimated_daily_reward=daily_reward\n    )\n\n@app.post("/unstake/{position_id}")\nasync def unstake_asset(position_id: str, user_id: str = "user123", db: Session = Depends(get_db)):\n    """Unstake assets"""\n    position = db.query(StakingPositionDB).filter(\n        StakingPositionDB.id == position_id,\n        StakingPositionDB.user_id == user_id\n    ).first()\n    \n    if not position:\n        raise HTTPException(status_code=404, detail="Position not found")\n    \n    if position.status != "active":\n        raise HTTPException(status_code=400, detail="Position is not active")\n    \n    # Check if locked period ended\n    if position.product_type == "locked" and position.end_date:\n        if datetime.utcnow() < position.end_date:\n            raise HTTPException(status_code=400, detail="Locked period has not ended")\n    \n    # Update position status\n    position.status = "completed"\n    \n    # Update product total staked\n    product = db.query(StakingProductDB).filter(StakingProductDB.id == position.product_id).first()\n    if product:\n        product.total_staked -= position.amount\n    \n    db.commit()\n    \n    return {\n        "message": "Unstaked successfully",\n        "position_id": position_id,\n        "amount": position.amount,\n        "total_rewards": position.total_rewards\n    }\n\n@app.get("/positions", response_model=List[StakingPositionResponse])\nasync def list_positions(user_id: str = "user123", status: Optional[str] = None, db: Session = Depends(get_db)):\n    """List user staking positions"""\n    query = db.query(StakingPositionDB).filter(StakingPositionDB.user_id == user_id)\n    \n    if status:\n        query = query.filter(StakingPositionDB.status == status)\n    \n    positions = query.all()\n    \n    return [StakingPositionResponse(\n        id=pos.id,\n        user_id=pos.user_id,\n        product_id=pos.product_id,\n        asset=pos.asset,\n        amount=pos.amount,\n        apy=pos.apy,\n        product_type=pos.product_type,\n        duration_days=pos.duration_days,\n        start_date=pos.start_date,\n        end_date=pos.end_date,\n        status=pos.status,\n        total_rewards=pos.total_rewards,\n        estimated_daily_reward=(pos.amount * pos.apy / 100) / 365\n    ) for pos in positions]\n\n@app.get("/rewards", response_model=List[RewardResponse])\nasync def list_rewards(user_id: str = "user123", db: Session = Depends(get_db)):\n    """List user staking rewards"""\n    rewards = db.query(StakingRewardDB).filter(\n        StakingRewardDB.user_id == user_id\n    ).order_by(StakingRewardDB.reward_date.desc()).all()\n    \n    return [RewardResponse(\n        id=r.id,\n        position_id=r.position_id,\n        user_id=r.user_id,\n        asset=r.asset,\n        amount=r.amount,\n        reward_date=r.reward_date,\n        status=r.status\n    ) for r in rewards]\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "staking"}\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8003)\n</create-file>\n</function_calls>'}