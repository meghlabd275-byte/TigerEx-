{'role': 'assistant', 'content': '\n<function_calls>\n<create-file file_path="backend/defi-enhancements-service/src/main.py">\n"""\nTigerEx DeFi Enhancements Service\nAdditional DEX protocols and cross-chain bridge integrations\nPort: 8125\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_defi_enhancements"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass DEXProtocol(str, Enum):\n    # Existing protocols\n    UNISWAP_V2 = "uniswap_v2"\n    UNISWAP_V3 = "uniswap_v3"\n    SUSHISWAP = "sushiswap"\n    PANCAKESWAP = "pancakeswap"\n    CURVE = "curve"\n    BALANCER = "balancer"\n    \n    # New protocols\n    TRADER_JOE = "trader_joe"\n    SPOOKYSWAP = "spookyswap"\n    QUICKSWAP = "quickswap"\n    RAYDIUM = "raydium"\n    ORCA = "orca"\n    SERUM = "serum"\n    OSMOSIS = "osmosis"\n\nclass BridgeProtocol(str, Enum):\n    THORCHAIN = "thorchain"\n    SYNAPSE = "synapse"\n    HOP_PROTOCOL = "hop_protocol"\n    MULTICHAIN = "multichain"\n    WORMHOLE = "wormhole"\n    CELER = "celer"\n\nclass ChainType(str, Enum):\n    ETHEREUM = "ethereum"\n    BSC = "bsc"\n    POLYGON = "polygon"\n    AVALANCHE = "avalanche"\n    FANTOM = "fantom"\n    ARBITRUM = "arbitrum"\n    OPTIMISM = "optimism"\n    SOLANA = "solana"\n    COSMOS = "cosmos"\n    TERRA = "terra"\n\n# Database Models\nclass DEXProtocolConfig(Base):\n    __tablename__ = "dex_protocol_configs"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    protocol = Column(String, unique=True, index=True)\n    chain = Column(String, index=True)\n    router_address = Column(String)\n    factory_address = Column(String)\n    is_enabled = Column(Boolean, default=True)\n    \n    # Protocol features\n    supports_limit_orders = Column(Boolean, default=False)\n    supports_concentrated_liquidity = Column(Boolean, default=False)\n    supports_multi_hop = Column(Boolean, default=True)\n    \n    # Fee structure\n    default_fee_bps = Column(Integer, default=30)\n    \n    # Stats\n    total_liquidity_usd = Column(Float, default=0.0)\n    volume_24h_usd = Column(Float, default=0.0)\n    total_pools = Column(Integer, default=0)\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass BridgeConfig(Base):\n    __tablename__ = "bridge_configs"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    protocol = Column(String, unique=True, index=True)\n    is_enabled = Column(Boolean, default=True)\n    \n    # Supported chains\n    supported_chains = Column(JSON)\n    \n    # Bridge features\n    supports_native_tokens = Column(Boolean, default=True)\n    supports_erc20 = Column(Boolean, default=True)\n    supports_nft = Column(Boolean, default=False)\n    \n    # Limits\n    min_bridge_amount = Column(Float, default=10.0)\n    max_bridge_amount = Column(Float, default=1000000.0)\n    \n    # Fees\n    base_fee_percentage = Column(Float, default=0.1)\n    gas_fee_estimate = Column(Float, default=0.0)\n    \n    # Performance\n    avg_bridge_time_minutes = Column(Integer, default=15)\n    success_rate = Column(Float, default=99.0)\n    \n    # Stats\n    total_volume_usd = Column(Float, default=0.0)\n    total_transactions = Column(Integer, default=0)\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass CrossChainTransaction(Base):\n    __tablename__ = "cross_chain_transactions"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    transaction_id = Column(String, unique=True, index=True)\n    user_id = Column(Integer, index=True)\n    bridge_protocol = Column(String, index=True)\n    \n    # Source chain\n    source_chain = Column(String)\n    source_token = Column(String)\n    source_amount = Column(Float)\n    source_tx_hash = Column(String, nullable=True)\n    \n    # Destination chain\n    destination_chain = Column(String)\n    destination_token = Column(String)\n    destination_amount = Column(Float)\n    destination_tx_hash = Column(String, nullable=True)\n    \n    # Fees\n    bridge_fee = Column(Float)\n    gas_fee = Column(Float)\n    \n    # Status\n    status = Column(String, default="pending")\n    \n    # Timestamps\n    created_at = Column(DateTime, default=datetime.utcnow)\n    confirmed_at = Column(DateTime, nullable=True)\n    completed_at = Column(DateTime, nullable=True)\n    \n    metadata = Column(JSON)\n\nclass DEXSwap(Base):\n    __tablename__ = "dex_swaps"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    swap_id = Column(String, unique=True, index=True)\n    user_id = Column(Integer, index=True)\n    protocol = Column(String, index=True)\n    chain = Column(String)\n    \n    # Swap details\n    token_in = Column(String)\n    token_out = Column(String)\n    amount_in = Column(Float)\n    amount_out = Column(Float)\n    \n    # Route\n    route_path = Column(JSON)\n    \n    # Pricing\n    price = Column(Float)\n    price_impact = Column(Float)\n    slippage = Column(Float)\n    \n    # Execution\n    tx_hash = Column(String, nullable=True)\n    gas_used = Column(Float, nullable=True)\n    \n    # Status\n    status = Column(String, default="pending")\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime, nullable=True)\n    \n    metadata = Column(JSON)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass DEXProtocolCreate(BaseModel):\n    protocol: DEXProtocol\n    chain: ChainType\n    router_address: str\n    factory_address: str\n    supports_limit_orders: bool = False\n    supports_concentrated_liquidity: bool = False\n    default_fee_bps: int = Field(ge=0, le=10000, default=30)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass BridgeConfigCreate(BaseModel):\n    protocol: BridgeProtocol\n    supported_chains: List[str]\n    supports_native_tokens: bool = True\n    supports_erc20: bool = True\n    supports_nft: bool = False\n    min_bridge_amount: float = Field(ge=0, default=10.0)\n    max_bridge_amount: float = Field(ge=0, default=1000000.0)\n    base_fee_percentage: float = Field(ge=0, le=10, default=0.1)\n    avg_bridge_time_minutes: int = Field(ge=0, default=15)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass CrossChainBridgeRequest(BaseModel):\n    user_id: int\n    bridge_protocol: BridgeProtocol\n    source_chain: ChainType\n    source_token: str\n    source_amount: float = Field(gt=0)\n    destination_chain: ChainType\n    destination_token: str\n    slippage_tolerance: float = Field(ge=0, le=100, default=0.5)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass DEXSwapRequest(BaseModel):\n    user_id: int\n    protocol: DEXProtocol\n    chain: ChainType\n    token_in: str\n    token_out: str\n    amount_in: float = Field(gt=0)\n    slippage_tolerance: float = Field(ge=0, le=100, default=0.5)\n    metadata: Optional[Dict[str, Any]] = None\n\napp = FastAPI(\n    title="TigerEx DeFi Enhancements Service",\n    description="Additional DEX protocols and cross-chain bridges",\n    version="1.0.0"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef generate_transaction_id(prefix: str) -> str:\n    import uuid\n    return f"{prefix}-{uuid.uuid4().hex[:16].upper()}"\n\n@app.post("/api/dex-protocols", status_code=201)\nasync def create_dex_protocol(protocol: DEXProtocolCreate, db: Session = Depends(get_db)):\n    try:\n        existing = db.query(DEXProtocolConfig).filter(\n            DEXProtocolConfig.protocol == protocol.protocol\n        ).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Protocol already exists")\n        \n        db_protocol = DEXProtocolConfig(**protocol.dict())\n        db.add(db_protocol)\n        db.commit()\n        db.refresh(db_protocol)\n        \n        logger.info(f"Added DEX protocol: {protocol.protocol}")\n        return db_protocol\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error adding DEX protocol: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/dex-protocols")\nasync def get_dex_protocols(\n    chain: Optional[ChainType] = None,\n    is_enabled: Optional[bool] = None,\n    db: Session = Depends(get_db)\n):\n    try:\n        query = db.query(DEXProtocolConfig)\n        \n        if chain:\n            query = query.filter(DEXProtocolConfig.chain == chain)\n        if is_enabled is not None:\n            query = query.filter(DEXProtocolConfig.is_enabled == is_enabled)\n        \n        protocols = query.all()\n        return protocols\n    except Exception as e:\n        logger.error(f"Error fetching DEX protocols: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    try:\n        total_dex_protocols = db.query(DEXProtocolConfig).count()\n        active_dex_protocols = db.query(DEXProtocolConfig).filter(\n            DEXProtocolConfig.is_enabled == True\n        ).count()\n        \n        total_bridges = db.query(BridgeConfig).count()\n        active_bridges = db.query(BridgeConfig).filter(\n            BridgeConfig.is_enabled == True\n        ).count()\n        \n        return {\n            "total_dex_protocols": total_dex_protocols,\n            "active_dex_protocols": active_dex_protocols,\n            "total_bridges": total_bridges,\n            "active_bridges": active_bridges\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "defi-enhancements"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8125)\n</create-file>\n</function_calls>\n</function_calls>'}