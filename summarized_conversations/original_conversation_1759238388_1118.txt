{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/unified-account-service/main.py">\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\nfrom enum import Enum\nimport uuid\nimport logging\nfrom sqlalchemy import create_engine, Column, String, Float, Integer, DateTime, Boolean, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title="Unified Trading Account Service", version="1.0.0")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/unified_account"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Database Models\nclass UnifiedAccountDB(Base):\n    __tablename__ = "unified_accounts"\n    \n    id = Column(String, primary_key=True)\n    user_id = Column(String, nullable=False, unique=True, index=True)\n    total_equity = Column(Float, default=0.0)\n    available_balance = Column(Float, default=0.0)\n    margin_used = Column(Float, default=0.0)\n    margin_available = Column(Float, default=0.0)\n    unrealized_pnl = Column(Float, default=0.0)\n    realized_pnl = Column(Float, default=0.0)\n    margin_level = Column(Float, default=0.0)\n    account_mode = Column(String, default="single")  # single, portfolio, cross\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass AccountPositionDB(Base):\n    __tablename__ = "account_positions"\n    \n    id = Column(String, primary_key=True)\n    account_id = Column(String, nullable=False, index=True)\n    symbol = Column(String, nullable=False)\n    position_type = Column(String, nullable=False)  # spot, futures, margin\n    side = Column(String, nullable=False)  # long, short\n    size = Column(Float, nullable=False)\n    entry_price = Column(Float, nullable=False)\n    current_price = Column(Float, nullable=False)\n    unrealized_pnl = Column(Float, default=0.0)\n    margin_used = Column(Float, default=0.0)\n    leverage = Column(Float, default=1.0)\n    liquidation_price = Column(Float, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass AccountAssetDB(Base):\n    __tablename__ = "account_assets"\n    \n    id = Column(String, primary_key=True)\n    account_id = Column(String, nullable=False, index=True)\n    asset = Column(String, nullable=False)\n    total_balance = Column(Float, default=0.0)\n    available_balance = Column(Float, default=0.0)\n    locked_balance = Column(Float, default=0.0)\n    usd_value = Column(Float, default=0.0)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Pydantic Models\nclass AccountMode(str, Enum):\n    SINGLE = "single"\n    PORTFOLIO = "portfolio"\n    CROSS = "cross"\n\nclass UnifiedAccountCreate(BaseModel):\n    user_id: str\n    account_mode: AccountMode = AccountMode.SINGLE\n\nclass UnifiedAccountResponse(BaseModel):\n    id: str\n    user_id: str\n    total_equity: float\n    available_balance: float\n    margin_used: float\n    margin_available: float\n    unrealized_pnl: float\n    realized_pnl: float\n    margin_level: float\n    account_mode: str\n    created_at: datetime\n    updated_at: datetime\n\nclass PositionResponse(BaseModel):\n    id: str\n    account_id: str\n    symbol: str\n    position_type: str\n    side: str\n    size: float\n    entry_price: float\n    current_price: float\n    unrealized_pnl: float\n    margin_used: float\n    leverage: float\n    liquidation_price: Optional[float]\n\nclass AssetResponse(BaseModel):\n    id: str\n    account_id: str\n    asset: str\n    total_balance: float\n    available_balance: float\n    locked_balance: float\n    usd_value: float\n\n# API Endpoints\n@app.post("/accounts", response_model=UnifiedAccountResponse)\nasync def create_account(account: UnifiedAccountCreate, db: Session = Depends(get_db)):\n    """Create a unified trading account"""\n    existing = db.query(UnifiedAccountDB).filter(UnifiedAccountDB.user_id == account.user_id).first()\n    if existing:\n        raise HTTPException(status_code=400, detail="Account already exists")\n    \n    account_id = str(uuid.uuid4())\n    db_account = UnifiedAccountDB(\n        id=account_id,\n        user_id=account.user_id,\n        account_mode=account.account_mode,\n        created_at=datetime.utcnow()\n    )\n    \n    db.add(db_account)\n    db.commit()\n    db.refresh(db_account)\n    \n    return UnifiedAccountResponse(\n        id=db_account.id,\n        user_id=db_account.user_id,\n        total_equity=db_account.total_equity,\n        available_balance=db_account.available_balance,\n        margin_used=db_account.margin_used,\n        margin_available=db_account.margin_available,\n        unrealized_pnl=db_account.unrealized_pnl,\n        realized_pnl=db_account.realized_pnl,\n        margin_level=db_account.margin_level,\n        account_mode=db_account.account_mode,\n        created_at=db_account.created_at,\n        updated_at=db_account.updated_at\n    )\n\n@app.get("/accounts/{user_id}", response_model=UnifiedAccountResponse)\nasync def get_account(user_id: str, db: Session = Depends(get_db)):\n    """Get unified account details"""\n    account = db.query(UnifiedAccountDB).filter(UnifiedAccountDB.user_id == user_id).first()\n    if not account:\n        raise HTTPException(status_code=404, detail="Account not found")\n    \n    return UnifiedAccountResponse(\n        id=account.id,\n        user_id=account.user_id,\n        total_equity=account.total_equity,\n        available_balance=account.available_balance,\n        margin_used=account.margin_used,\n        margin_available=account.margin_available,\n        unrealized_pnl=account.unrealized_pnl,\n        realized_pnl=account.realized_pnl,\n        margin_level=account.margin_level,\n        account_mode=account.account_mode,\n        created_at=account.created_at,\n        updated_at=account.updated_at\n    )\n\n@app.get("/accounts/{user_id}/positions", response_model=List[PositionResponse])\nasync def get_positions(user_id: str, db: Session = Depends(get_db)):\n    """Get all positions for unified account"""\n    account = db.query(UnifiedAccountDB).filter(UnifiedAccountDB.user_id == user_id).first()\n    if not account:\n        raise HTTPException(status_code=404, detail="Account not found")\n    \n    positions = db.query(AccountPositionDB).filter(AccountPositionDB.account_id == account.id).all()\n    \n    return [PositionResponse(\n        id=pos.id,\n        account_id=pos.account_id,\n        symbol=pos.symbol,\n        position_type=pos.position_type,\n        side=pos.side,\n        size=pos.size,\n        entry_price=pos.entry_price,\n        current_price=pos.current_price,\n        unrealized_pnl=pos.unrealized_pnl,\n        margin_used=pos.margin_used,\n        leverage=pos.leverage,\n        liquidation_price=pos.liquidation_price\n    ) for pos in positions]\n\n@app.get("/accounts/{user_id}/assets", response_model=List[AssetResponse])\nasync def get_assets(user_id: str, db: Session = Depends(get_db)):\n    """Get all assets in unified account"""\n    account = db.query(UnifiedAccountDB).filter(UnifiedAccountDB.user_id == user_id).first()\n    if not account:\n        raise HTTPException(status_code=404, detail="Account not found")\n    \n    assets = db.query(AccountAssetDB).filter(AccountAssetDB.account_id == account.id).all()\n    \n    return [AssetResponse(\n        id=asset.id,\n        account_id=asset.account_id,\n        asset=asset.asset,\n        total_balance=asset.total_balance,\n        available_balance=asset.available_balance,\n        locked_balance=asset.locked_balance,\n        usd_value=asset.usd_value\n    ) for asset in assets]\n\n@app.post("/accounts/{user_id}/mode")\nasync def change_account_mode(user_id: str, mode: AccountMode, db: Session = Depends(get_db)):\n    """Change account mode"""\n    account = db.query(UnifiedAccountDB).filter(UnifiedAccountDB.user_id == user_id).first()\n    if not account:\n        raise HTTPException(status_code=404, detail="Account not found")\n    \n    account.account_mode = mode\n    account.updated_at = datetime.utcnow()\n    db.commit()\n    \n    return {"message": "Account mode updated", "mode": mode}\n\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "unified-account"}\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8002)\n</create-file>\n</function_calls>'}