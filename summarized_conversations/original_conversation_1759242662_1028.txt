{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/dex-integration-admin/src/main.py">\n"""\nTigerEx DEX Integration Admin Panel\nManages decentralized exchange integrations, liquidity pools, and routing\nPort: 8117\n"""\n\nfrom fastapi import FastAPI, HTTPException, Depends, Query\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport uvicorn\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, JSON, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Database setup\nDATABASE_URL = "postgresql://tigerex:tigerex123@localhost:5432/tigerex_dex_integration"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass DEXProtocol(str, Enum):\n    UNISWAP_V2 = "uniswap_v2"\n    UNISWAP_V3 = "uniswap_v3"\n    SUSHISWAP = "sushiswap"\n    PANCAKESWAP = "pancakeswap"\n    CURVE = "curve"\n    BALANCER = "balancer"\n    TRADER_JOE = "trader_joe"\n    SPOOKYSWAP = "spookyswap"\n    QUICKSWAP = "quickswap"\n    RAYDIUM = "raydium"\n    ORCA = "orca"\n    SERUM = "serum"\n    OSMOSIS = "osmosis"\n\nclass ChainType(str, Enum):\n    ETHEREUM = "ethereum"\n    BSC = "bsc"\n    POLYGON = "polygon"\n    AVALANCHE = "avalanche"\n    FANTOM = "fantom"\n    ARBITRUM = "arbitrum"\n    OPTIMISM = "optimism"\n    SOLANA = "solana"\n    COSMOS = "cosmos"\n\nclass PoolStatus(str, Enum):\n    ACTIVE = "active"\n    INACTIVE = "inactive"\n    PAUSED = "paused"\n    DEPRECATED = "deprecated"\n\n# Database Models\nclass DEXIntegration(Base):\n    __tablename__ = "dex_integrations"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, index=True)\n    protocol = Column(String, index=True)\n    chain = Column(String, index=True)\n    router_address = Column(String)\n    factory_address = Column(String)\n    \n    # Configuration\n    is_enabled = Column(Boolean, default=True)\n    supports_limit_orders = Column(Boolean, default=False)\n    supports_stop_loss = Column(Boolean, default=False)\n    min_trade_amount = Column(Float, default=0.0)\n    max_trade_amount = Column(Float, nullable=True)\n    \n    # Fees\n    swap_fee = Column(Float, default=0.3)  # percentage\n    gas_multiplier = Column(Float, default=1.2)\n    \n    # Stats\n    total_volume_24h = Column(Float, default=0.0)\n    total_volume_7d = Column(Float, default=0.0)\n    total_volume_30d = Column(Float, default=0.0)\n    total_trades = Column(Integer, default=0)\n    total_liquidity = Column(Float, default=0.0)\n    \n    # Status\n    last_sync = Column(DateTime, nullable=True)\n    is_syncing = Column(Boolean, default=False)\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass LiquidityPool(Base):\n    __tablename__ = "liquidity_pools"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    dex_id = Column(Integer, index=True)\n    pool_address = Column(String, unique=True, index=True)\n    \n    # Token pair\n    token0_address = Column(String, index=True)\n    token0_symbol = Column(String)\n    token0_decimals = Column(Integer)\n    token1_address = Column(String, index=True)\n    token1_symbol = Column(String)\n    token1_decimals = Column(Integer)\n    \n    # Pool info\n    reserve0 = Column(Float, default=0.0)\n    reserve1 = Column(Float, default=0.0)\n    total_liquidity = Column(Float, default=0.0)\n    liquidity_usd = Column(Float, default=0.0)\n    \n    # Trading stats\n    volume_24h = Column(Float, default=0.0)\n    volume_7d = Column(Float, default=0.0)\n    fees_24h = Column(Float, default=0.0)\n    apr = Column(Float, default=0.0)\n    \n    # Price\n    token0_price = Column(Float, default=0.0)\n    token1_price = Column(Float, default=0.0)\n    price_impact = Column(Float, default=0.0)\n    \n    # Status\n    status = Column(String, default="active")\n    is_verified = Column(Boolean, default=False)\n    \n    last_updated = Column(DateTime, default=datetime.utcnow)\n    metadata = Column(JSON)\n\nclass DEXRoute(Base):\n    __tablename__ = "dex_routes"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    \n    # Route info\n    token_in = Column(String, index=True)\n    token_out = Column(String, index=True)\n    amount_in = Column(Float)\n    \n    # Path\n    path = Column(JSON)  # Array of token addresses\n    pools = Column(JSON)  # Array of pool addresses\n    dexes = Column(JSON)  # Array of DEX IDs used\n    \n    # Pricing\n    amount_out = Column(Float)\n    price_impact = Column(Float)\n    gas_estimate = Column(Float)\n    \n    # Optimization\n    is_optimal = Column(Boolean, default=False)\n    split_routes = Column(JSON, nullable=True)  # For split routing\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    expires_at = Column(DateTime)\n\nclass DEXTrade(Base):\n    __tablename__ = "dex_trades"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    dex_id = Column(Integer, index=True)\n    pool_id = Column(Integer, index=True)\n    user_id = Column(Integer, index=True)\n    \n    # Trade details\n    token_in = Column(String)\n    token_out = Column(String)\n    amount_in = Column(Float)\n    amount_out = Column(Float)\n    \n    # Execution\n    tx_hash = Column(String, unique=True, index=True)\n    gas_used = Column(Float)\n    gas_price = Column(Float)\n    \n    # Pricing\n    price = Column(Float)\n    price_impact = Column(Float)\n    slippage = Column(Float)\n    \n    # Status\n    status = Column(String, default="pending")  # pending, confirmed, failed\n    \n    created_at = Column(DateTime, default=datetime.utcnow)\n    confirmed_at = Column(DateTime, nullable=True)\n    metadata = Column(JSON)\n\nclass DEXAnalytics(Base):\n    __tablename__ = "dex_analytics"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    dex_id = Column(Integer, index=True)\n    date = Column(DateTime, index=True)\n    \n    # Volume metrics\n    daily_volume = Column(Float)\n    daily_trades = Column(Integer)\n    unique_traders = Column(Integer)\n    \n    # Liquidity metrics\n    total_liquidity = Column(Float)\n    liquidity_change = Column(Float)\n    \n    # Fee metrics\n    total_fees = Column(Float)\n    avg_fee_per_trade = Column(Float)\n    \n    metadata = Column(JSON)\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass DEXIntegrationCreate(BaseModel):\n    name: str\n    protocol: DEXProtocol\n    chain: ChainType\n    router_address: str\n    factory_address: str\n    supports_limit_orders: bool = False\n    supports_stop_loss: bool = False\n    min_trade_amount: float = Field(ge=0, default=0.0)\n    max_trade_amount: Optional[float] = None\n    swap_fee: float = Field(ge=0, le=100, default=0.3)\n    gas_multiplier: float = Field(gt=0, default=1.2)\n    metadata: Optional[Dict[str, Any]] = None\n\nclass DEXIntegrationUpdate(BaseModel):\n    name: Optional[str] = None\n    router_address: Optional[str] = None\n    factory_address: Optional[str] = None\n    is_enabled: Optional[bool] = None\n    supports_limit_orders: Optional[bool] = None\n    supports_stop_loss: Optional[bool] = None\n    min_trade_amount: Optional[float] = None\n    max_trade_amount: Optional[float] = None\n    swap_fee: Optional[float] = None\n    gas_multiplier: Optional[float] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass LiquidityPoolCreate(BaseModel):\n    dex_id: int\n    pool_address: str\n    token0_address: str\n    token0_symbol: str\n    token0_decimals: int\n    token1_address: str\n    token1_symbol: str\n    token1_decimals: int\n    metadata: Optional[Dict[str, Any]] = None\n\nclass LiquidityPoolUpdate(BaseModel):\n    reserve0: Optional[float] = None\n    reserve1: Optional[float] = None\n    total_liquidity: Optional[float] = None\n    liquidity_usd: Optional[float] = None\n    volume_24h: Optional[float] = None\n    volume_7d: Optional[float] = None\n    fees_24h: Optional[float] = None\n    apr: Optional[float] = None\n    token0_price: Optional[float] = None\n    token1_price: Optional[float] = None\n    status: Optional[PoolStatus] = None\n    is_verified: Optional[bool] = None\n    metadata: Optional[Dict[str, Any]] = None\n\nclass RouteRequest(BaseModel):\n    token_in: str\n    token_out: str\n    amount_in: float\n    slippage_tolerance: float = Field(ge=0, le=100, default=0.5)\n    max_hops: int = Field(ge=1, le=5, default=3)\n\n# FastAPI app\napp = FastAPI(\n    title="TigerEx DEX Integration Admin API",\n    description="Admin panel for managing DEX integrations and liquidity pools",\n    version="1.0.0"\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# ==================== DEX INTEGRATION ENDPOINTS ====================\n\n@app.post("/api/admin/dex-integrations", status_code=201)\nasync def create_dex_integration(dex: DEXIntegrationCreate, db: Session = Depends(get_db)):\n    """Create a new DEX integration"""\n    try:\n        # Check if DEX already exists\n        existing = db.query(DEXIntegration).filter(DEXIntegration.name == dex.name).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="DEX integration already exists")\n        \n        db_dex = DEXIntegration(**dex.dict())\n        db.add(db_dex)\n        db.commit()\n        db.refresh(db_dex)\n        \n        logger.info(f"Created DEX integration: {dex.name}")\n        return db_dex\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating DEX integration: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/dex-integrations")\nasync def get_dex_integrations(\n    skip: int = 0,\n    limit: int = 100,\n    protocol: Optional[DEXProtocol] = None,\n    chain: Optional[ChainType] = None,\n    is_enabled: Optional[bool] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all DEX integrations with filters"""\n    try:\n        query = db.query(DEXIntegration)\n        \n        if protocol:\n            query = query.filter(DEXIntegration.protocol == protocol)\n        if chain:\n            query = query.filter(DEXIntegration.chain == chain)\n        if is_enabled is not None:\n            query = query.filter(DEXIntegration.is_enabled == is_enabled)\n        \n        total = query.count()\n        dexes = query.offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "dexes": dexes\n        }\n    except Exception as e:\n        logger.error(f"Error fetching DEX integrations: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/dex-integrations/{dex_id}")\nasync def get_dex_integration(dex_id: int, db: Session = Depends(get_db)):\n    """Get a specific DEX integration"""\n    dex = db.query(DEXIntegration).filter(DEXIntegration.id == dex_id).first()\n    if not dex:\n        raise HTTPException(status_code=404, detail="DEX integration not found")\n    return dex\n\n@app.put("/api/admin/dex-integrations/{dex_id}")\nasync def update_dex_integration(\n    dex_id: int,\n    dex_update: DEXIntegrationUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a DEX integration"""\n    try:\n        dex = db.query(DEXIntegration).filter(DEXIntegration.id == dex_id).first()\n        if not dex:\n            raise HTTPException(status_code=404, detail="DEX integration not found")\n        \n        update_data = dex_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(dex, field, value)\n        \n        dex.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(dex)\n        \n        logger.info(f"Updated DEX integration: {dex_id}")\n        return dex\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating DEX integration: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/admin/dex-integrations/{dex_id}/sync")\nasync def sync_dex_integration(dex_id: int, db: Session = Depends(get_db)):\n    """Trigger sync for a DEX integration"""\n    try:\n        dex = db.query(DEXIntegration).filter(DEXIntegration.id == dex_id).first()\n        if not dex:\n            raise HTTPException(status_code=404, detail="DEX integration not found")\n        \n        if dex.is_syncing:\n            raise HTTPException(status_code=400, detail="DEX is already syncing")\n        \n        dex.is_syncing = True\n        dex.last_sync = datetime.utcnow()\n        db.commit()\n        \n        # TODO: Trigger background sync task\n        \n        logger.info(f"Started sync for DEX: {dex_id}")\n        return {"message": "Sync started successfully"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error syncing DEX: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.delete("/api/admin/dex-integrations/{dex_id}")\nasync def delete_dex_integration(dex_id: int, db: Session = Depends(get_db)):\n    """Delete a DEX integration"""\n    try:\n        dex = db.query(DEXIntegration).filter(DEXIntegration.id == dex_id).first()\n        if not dex:\n            raise HTTPException(status_code=404, detail="DEX integration not found")\n        \n        # Check if DEX has active pools\n        active_pools = db.query(LiquidityPool).filter(\n            LiquidityPool.dex_id == dex_id,\n            LiquidityPool.status == "active"\n        ).count()\n        \n        if active_pools > 0:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Cannot delete DEX with {active_pools} active pools"\n            )\n        \n        db.delete(dex)\n        db.commit()\n        \n        logger.info(f"Deleted DEX integration: {dex_id}")\n        return {"message": "DEX integration deleted successfully"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error deleting DEX integration: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== LIQUIDITY POOL ENDPOINTS ====================\n\n@app.post("/api/admin/pools", status_code=201)\nasync def create_pool(pool: LiquidityPoolCreate, db: Session = Depends(get_db)):\n    """Create a new liquidity pool"""\n    try:\n        # Verify DEX exists\n        dex = db.query(DEXIntegration).filter(DEXIntegration.id == pool.dex_id).first()\n        if not dex:\n            raise HTTPException(status_code=404, detail="DEX integration not found")\n        \n        # Check if pool already exists\n        existing = db.query(LiquidityPool).filter(\n            LiquidityPool.pool_address == pool.pool_address\n        ).first()\n        if existing:\n            raise HTTPException(status_code=400, detail="Pool already exists")\n        \n        db_pool = LiquidityPool(**pool.dict())\n        db.add(db_pool)\n        db.commit()\n        db.refresh(db_pool)\n        \n        logger.info(f"Created liquidity pool: {pool.pool_address}")\n        return db_pool\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error creating pool: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/pools")\nasync def get_pools(\n    skip: int = 0,\n    limit: int = 100,\n    dex_id: Optional[int] = None,\n    token_address: Optional[str] = None,\n    status: Optional[PoolStatus] = None,\n    is_verified: Optional[bool] = None,\n    min_liquidity: Optional[float] = None,\n    db: Session = Depends(get_db)\n):\n    """Get all liquidity pools with filters"""\n    try:\n        query = db.query(LiquidityPool)\n        \n        if dex_id:\n            query = query.filter(LiquidityPool.dex_id == dex_id)\n        if token_address:\n            query = query.filter(\n                (LiquidityPool.token0_address == token_address) |\n                (LiquidityPool.token1_address == token_address)\n            )\n        if status:\n            query = query.filter(LiquidityPool.status == status)\n        if is_verified is not None:\n            query = query.filter(LiquidityPool.is_verified == is_verified)\n        if min_liquidity:\n            query = query.filter(LiquidityPool.liquidity_usd >= min_liquidity)\n        \n        total = query.count()\n        pools = query.order_by(LiquidityPool.liquidity_usd.desc()).offset(skip).limit(limit).all()\n        \n        return {\n            "total": total,\n            "pools": pools\n        }\n    except Exception as e:\n        logger.error(f"Error fetching pools: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/pools/{pool_id}")\nasync def get_pool(pool_id: int, db: Session = Depends(get_db)):\n    """Get a specific liquidity pool"""\n    pool = db.query(LiquidityPool).filter(LiquidityPool.id == pool_id).first()\n    if not pool:\n        raise HTTPException(status_code=404, detail="Pool not found")\n    return pool\n\n@app.put("/api/admin/pools/{pool_id}")\nasync def update_pool(\n    pool_id: int,\n    pool_update: LiquidityPoolUpdate,\n    db: Session = Depends(get_db)\n):\n    """Update a liquidity pool"""\n    try:\n        pool = db.query(LiquidityPool).filter(LiquidityPool.id == pool_id).first()\n        if not pool:\n            raise HTTPException(status_code=404, detail="Pool not found")\n        \n        update_data = pool_update.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(pool, field, value)\n        \n        pool.last_updated = datetime.utcnow()\n        db.commit()\n        db.refresh(pool)\n        \n        logger.info(f"Updated pool: {pool_id}")\n        return pool\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error updating pool: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post("/api/admin/pools/{pool_id}/verify")\nasync def verify_pool(pool_id: int, db: Session = Depends(get_db)):\n    """Verify a liquidity pool"""\n    try:\n        pool = db.query(LiquidityPool).filter(LiquidityPool.id == pool_id).first()\n        if not pool:\n            raise HTTPException(status_code=404, detail="Pool not found")\n        \n        pool.is_verified = True\n        db.commit()\n        \n        logger.info(f"Verified pool: {pool_id}")\n        return {"message": "Pool verified successfully"}\n    except Exception as e:\n        db.rollback()\n        logger.error(f"Error verifying pool: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== ROUTING ENDPOINTS ====================\n\n@app.post("/api/admin/routes/find-best")\nasync def find_best_route(route_request: RouteRequest, db: Session = Depends(get_db)):\n    """Find the best route for a swap"""\n    try:\n        # TODO: Implement routing algorithm\n        # This is a placeholder response\n        \n        return {\n            "token_in": route_request.token_in,\n            "token_out": route_request.token_out,\n            "amount_in": route_request.amount_in,\n            "amount_out": 0.0,  # Calculate based on routing\n            "path": [],\n            "pools": [],\n            "dexes": [],\n            "price_impact": 0.0,\n            "gas_estimate": 0.0\n        }\n    except Exception as e:\n        logger.error(f"Error finding route: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# ==================== ANALYTICS ENDPOINTS ====================\n\n@app.get("/api/admin/analytics/overview")\nasync def get_analytics_overview(db: Session = Depends(get_db)):\n    """Get overall DEX analytics"""\n    try:\n        total_dexes = db.query(DEXIntegration).count()\n        active_dexes = db.query(DEXIntegration).filter(DEXIntegration.is_enabled == True).count()\n        total_pools = db.query(LiquidityPool).count()\n        active_pools = db.query(LiquidityPool).filter(LiquidityPool.status == "active").count()\n        \n        total_liquidity = db.query(LiquidityPool).with_entities(\n            db.func.sum(LiquidityPool.liquidity_usd)\n        ).scalar() or 0.0\n        \n        total_volume_24h = db.query(DEXIntegration).with_entities(\n            db.func.sum(DEXIntegration.total_volume_24h)\n        ).scalar() or 0.0\n        \n        return {\n            "total_dexes": total_dexes,\n            "active_dexes": active_dexes,\n            "total_pools": total_pools,\n            "active_pools": active_pools,\n            "total_liquidity": total_liquidity,\n            "total_volume_24h": total_volume_24h\n        }\n    except Exception as e:\n        logger.error(f"Error fetching analytics: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/admin/analytics/top-pools")\nasync def get_top_pools(\n    metric: str = "liquidity",\n    limit: int = 10,\n    db: Session = Depends(get_db)\n):\n    """Get top liquidity pools"""\n    try:\n        query = db.query(LiquidityPool).filter(LiquidityPool.status == "active")\n        \n        if metric == "liquidity":\n            query = query.order_by(LiquidityPool.liquidity_usd.desc())\n        elif metric == "volume":\n            query = query.order_by(LiquidityPool.volume_24h.desc())\n        elif metric == "apr":\n            query = query.order_by(LiquidityPool.apr.desc())\n        \n        pools = query.limit(limit).all()\n        return pools\n    except Exception as e:\n        logger.error(f"Error fetching top pools: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Health check\n@app.get("/health")\nasync def health_check():\n    return {"status": "healthy", "service": "dex-integration-admin"}\n\nif __name__ == "__main__":\n    uvicorn.run(app, host="0.0.0.0", port=8117)\n</create-file>\n</function_calls>'}