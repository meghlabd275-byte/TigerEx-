{'role': 'assistant', 'content': 'Now let me start implementing the critical missing features. I\'ll begin with creating the Trading Bots Service:\n\n<function_calls>\n<create-file file_path="tigerex/backend/trading-bots-service/main.py">\n"""\nTigerEx Trading Bots Service\nAutomated trading bots including Grid, DCA, Martingale, Arbitrage, and Market Making\n"""\n\nimport asyncio\nimport json\nimport logging\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Any\nfrom enum import Enum\nimport uuid\n\nfrom fastapi import FastAPI, HTTPException, Depends, WebSocket, WebSocketDisconnect\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, validator\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, Boolean, DateTime, Text, JSON, Enum as SQLEnum, BigInteger\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.sql import func\nimport aioredis\nimport asyncpg\nimport numpy as np\nimport pandas as pd\nfrom decimal import Decimal\nimport ccxt.async_support as ccxt\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# FastAPI app\napp = FastAPI(\n    title="TigerEx Trading Bots Service",\n    description="Automated trading bots with multiple strategies",\n    version="1.0.0"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Configuration\nclass Config:\n    DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:password@localhost/tigerex")\n    REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")\n    TRADING_ENGINE_URL = os.getenv("TRADING_ENGINE_URL", "http://localhost:8081")\n    MARKET_DATA_URL = os.getenv("MARKET_DATA_URL", "http://localhost:8106")\n\nconfig = Config()\n\n# Database setup\nengine = create_engine(config.DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Enums\nclass BotType(str, Enum):\n    GRID = "grid"\n    DCA = "dca"\n    MARTINGALE = "martingale"\n    ARBITRAGE = "arbitrage"\n    MARKET_MAKING = "market_making"\n    SMART_REBALANCE = "smart_rebalance"\n    TRAILING_STOP = "trailing_stop"\n    ICEBERG = "iceberg"\n\nclass BotStatus(str, Enum):\n    CREATED = "created"\n    RUNNING = "running"\n    PAUSED = "paused"\n    STOPPED = "stopped"\n    ERROR = "error"\n    COMPLETED = "completed"\n\nclass OrderSide(str, Enum):\n    BUY = "buy"\n    SELL = "sell"\n\n# Database Models\nclass TradingBot(Base):\n    __tablename__ = "trading_bots"\n    \n    id = Column(BigInteger, primary_key=True, index=True)\n    user_id = Column(BigInteger, nullable=False, index=True)\n    bot_type = Column(SQLEnum(BotType), nullable=False)\n    name = Column(String(255))\n    symbol = Column(String(20), nullable=False)\n    config = Column(JSON)\n    status = Column(SQLEnum(BotStatus), default=BotStatus.CREATED)\n    total_profit = Column(Float, default=0.0)\n    total_trades = Column(Integer, default=0)\n    win_rate = Column(Float, default=0.0)\n    created_at = Column(DateTime, default=func.now())\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())\n    started_at = Column(DateTime)\n    stopped_at = Column(DateTime)\n\nclass BotTrade(Base):\n    __tablename__ = "bot_trades"\n    \n    id = Column(BigInteger, primary_key=True, index=True)\n    bot_id = Column(BigInteger, nullable=False, index=True)\n    order_id = Column(BigInteger)\n    symbol = Column(String(20), nullable=False)\n    side = Column(SQLEnum(OrderSide), nullable=False)\n    price = Column(Float, nullable=False)\n    quantity = Column(Float, nullable=False)\n    profit_loss = Column(Float, default=0.0)\n    fee = Column(Float, default=0.0)\n    created_at = Column(DateTime, default=func.now())\n\nclass BotPerformance(Base):\n    __tablename__ = "bot_performance"\n    \n    id = Column(BigInteger, primary_key=True, index=True)\n    bot_id = Column(BigInteger, nullable=False, index=True)\n    timestamp = Column(DateTime, default=func.now())\n    total_value = Column(Float)\n    profit_loss = Column(Float)\n    roi = Column(Float)\n    sharpe_ratio = Column(Float)\n    max_drawdown = Column(Float)\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Models\nclass BotConfig(BaseModel):\n    # Grid Bot Config\n    grid_levels: Optional[int] = 10\n    price_range_low: Optional[float] = None\n    price_range_high: Optional[float] = None\n    investment_amount: Optional[float] = None\n    \n    # DCA Bot Config\n    dca_interval: Optional[str] = "1h"  # 1h, 4h, 1d, 1w\n    dca_amount: Optional[float] = None\n    target_profit: Optional[float] = None\n    \n    # Martingale Bot Config\n    initial_amount: Optional[float] = None\n    multiplier: Optional[float] = 2.0\n    max_orders: Optional[int] = 5\n    \n    # Arbitrage Bot Config\n    exchanges: Optional[List[str]] = []\n    min_profit_percentage: Optional[float] = 0.5\n    \n    # Market Making Bot Config\n    spread_percentage: Optional[float] = 0.2\n    order_amount: Optional[float] = None\n    max_position: Optional[float] = None\n    \n    # Common Config\n    stop_loss: Optional[float] = None\n    take_profit: Optional[float] = None\n    max_daily_loss: Optional[float] = None\n    trailing_stop: Optional[float] = None\n\nclass CreateBotRequest(BaseModel):\n    bot_type: BotType\n    name: str\n    symbol: str\n    config: BotConfig\n\nclass BotResponse(BaseModel):\n    id: int\n    user_id: int\n    bot_type: BotType\n    name: str\n    symbol: str\n    config: Dict\n    status: BotStatus\n    total_profit: float\n    total_trades: int\n    win_rate: float\n    created_at: datetime\n    started_at: Optional[datetime]\n    stopped_at: Optional[datetime]\n\nclass BotPerformanceResponse(BaseModel):\n    bot_id: int\n    total_value: float\n    profit_loss: float\n    roi: float\n    sharpe_ratio: float\n    max_drawdown: float\n    trades: List[Dict]\n    performance_history: List[Dict]\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# Redis connection\nredis_client = None\n\n@app.on_event("startup")\nasync def startup_event():\n    global redis_client\n    redis_client = await aioredis.create_redis_pool(config.REDIS_URL)\n    logger.info("Trading Bots Service started")\n\n@app.on_event("shutdown")\nasync def shutdown_event():\n    if redis_client:\n        redis_client.close()\n        await redis_client.wait_closed()\n    logger.info("Trading Bots Service stopped")\n\n# Bot Strategy Implementations\nclass GridTradingBot:\n    """Grid Trading Bot Strategy"""\n    \n    def __init__(self, bot_id: int, config: BotConfig, symbol: str):\n        self.bot_id = bot_id\n        self.config = config\n        self.symbol = symbol\n        self.grid_levels = config.grid_levels\n        self.price_low = config.price_range_low\n        self.price_high = config.price_range_high\n        self.investment = config.investment_amount\n        self.orders = []\n        \n    async def initialize(self):\n        """Initialize grid levels and place orders"""\n        price_step = (self.price_high - self.price_low) / self.grid_levels\n        amount_per_grid = self.investment / self.grid_levels\n        \n        # Create buy and sell orders at each grid level\n        for i in range(self.grid_levels):\n            buy_price = self.price_low + (i * price_step)\n            sell_price = buy_price + price_step\n            \n            # Place buy order\n            buy_order = {\n                "price": buy_price,\n                "amount": amount_per_grid / buy_price,\n                "side": "buy",\n                "status": "pending"\n            }\n            \n            # Place sell order\n            sell_order = {\n                "price": sell_price,\n                "amount": amount_per_grid / buy_price,\n                "side": "sell",\n                "status": "pending"\n            }\n            \n            self.orders.extend([buy_order, sell_order])\n        \n        return self.orders\n    \n    async def execute(self, current_price: float):\n        """Execute grid trading logic"""\n        executed_orders = []\n        \n        for order in self.orders:\n            if order["status"] == "pending":\n                if order["side"] == "buy" and current_price <= order["price"]:\n                    # Execute buy order\n                    order["status"] = "filled"\n                    executed_orders.append(order)\n                elif order["side"] == "sell" and current_price >= order["price"]:\n                    # Execute sell order\n                    order["status"] = "filled"\n                    executed_orders.append(order)\n        \n        return executed_orders\n\nclass DCABot:\n    """Dollar-Cost Averaging Bot Strategy"""\n    \n    def __init__(self, bot_id: int, config: BotConfig, symbol: str):\n        self.bot_id = bot_id\n        self.config = config\n        self.symbol = symbol\n        self.interval = config.dca_interval\n        self.amount = config.dca_amount\n        self.target_profit = config.target_profit\n        self.total_invested = 0\n        self.total_quantity = 0\n        self.last_buy_time = None\n        \n    async def should_buy(self) -> bool:\n        """Check if it\'s time to buy"""\n        if self.last_buy_time is None:\n            return True\n        \n        interval_map = {\n            "1h": timedelta(hours=1),\n            "4h": timedelta(hours=4),\n            "1d": timedelta(days=1),\n            "1w": timedelta(weeks=1)\n        }\n        \n        time_since_last_buy = datetime.now() - self.last_buy_time\n        return time_since_last_buy >= interval_map.get(self.interval, timedelta(hours=1))\n    \n    async def execute(self, current_price: float):\n        """Execute DCA strategy"""\n        if await self.should_buy():\n            quantity = self.amount / current_price\n            self.total_invested += self.amount\n            self.total_quantity += quantity\n            self.last_buy_time = datetime.now()\n            \n            avg_price = self.total_invested / self.total_quantity\n            current_value = self.total_quantity * current_price\n            profit_percentage = ((current_value - self.total_invested) / self.total_invested) * 100\n            \n            # Check if target profit reached\n            if self.target_profit and profit_percentage >= self.target_profit:\n                return {\n                    "action": "sell_all",\n                    "quantity": self.total_quantity,\n                    "profit": current_value - self.total_invested\n                }\n            \n            return {\n                "action": "buy",\n                "price": current_price,\n                "quantity": quantity,\n                "amount": self.amount\n            }\n        \n        return None\n\nclass MartingaleBot:\n    """Martingale Trading Bot Strategy"""\n    \n    def __init__(self, bot_id: int, config: BotConfig, symbol: str):\n        self.bot_id = bot_id\n        self.config = config\n        self.symbol = symbol\n        self.initial_amount = config.initial_amount\n        self.multiplier = config.multiplier\n        self.max_orders = config.max_orders\n        self.current_order = 0\n        self.current_amount = self.initial_amount\n        self.positions = []\n        \n    async def execute(self, current_price: float, last_trade_result: str):\n        """Execute Martingale strategy"""\n        if last_trade_result == "loss" and self.current_order < self.max_orders:\n            # Double the bet after loss\n            self.current_amount *= self.multiplier\n            self.current_order += 1\n        elif last_trade_result == "win":\n            # Reset to initial amount after win\n            self.current_amount = self.initial_amount\n            self.current_order = 0\n        \n        if self.current_order < self.max_orders:\n            return {\n                "action": "buy",\n                "price": current_price,\n                "amount": self.current_amount,\n                "order_number": self.current_order\n            }\n        \n        return None\n\nclass ArbitrageBot:\n    """Arbitrage Trading Bot Strategy"""\n    \n    def __init__(self, bot_id: int, config: BotConfig, symbol: str):\n        self.bot_id = bot_id\n        self.config = config\n        self.symbol = symbol\n        self.exchanges = config.exchanges\n        self.min_profit = config.min_profit_percentage\n        \n    async def find_arbitrage_opportunity(self, prices: Dict[str, float]):\n        """Find arbitrage opportunities across exchanges"""\n        if len(prices) < 2:\n            return None\n        \n        min_exchange = min(prices, key=prices.get)\n        max_exchange = max(prices, key=prices.get)\n        \n        min_price = prices[min_exchange]\n        max_price = prices[max_exchange]\n        \n        profit_percentage = ((max_price - min_price) / min_price) * 100\n        \n        if profit_percentage >= self.min_profit:\n            return {\n                "buy_exchange": min_exchange,\n                "sell_exchange": max_exchange,\n                "buy_price": min_price,\n                "sell_price": max_price,\n                "profit_percentage": profit_percentage\n            }\n        \n        return None\n\nclass MarketMakingBot:\n    """Market Making Bot Strategy"""\n    \n    def __init__(self, bot_id: int, config: BotConfig, symbol: str):\n        self.bot_id = bot_id\n        self.config = config\n        self.symbol = symbol\n        self.spread = config.spread_percentage\n        self.order_amount = config.order_amount\n        self.max_position = config.max_position\n        self.current_position = 0\n        \n    async def execute(self, current_price: float, order_book: Dict):\n        """Execute market making strategy"""\n        buy_price = current_price * (1 - self.spread / 100)\n        sell_price = current_price * (1 + self.spread / 100)\n        \n        orders = []\n        \n        # Place buy order if not at max position\n        if self.current_position < self.max_position:\n            orders.append({\n                "side": "buy",\n                "price": buy_price,\n                "amount": self.order_amount\n            })\n        \n        # Place sell order if have position\n        if self.current_position > 0:\n            orders.append({\n                "side": "sell",\n                "price": sell_price,\n                "amount": self.order_amount\n            })\n        \n        return orders\n\n# Bot Manager\nclass BotManager:\n    """Manages all trading bots"""\n    \n    def __init__(self):\n        self.active_bots: Dict[int, Any] = {}\n        self.bot_tasks: Dict[int, asyncio.Task] = {}\n    \n    async def start_bot(self, bot_id: int, bot_type: BotType, config: BotConfig, symbol: str, db: Session):\n        """Start a trading bot"""\n        if bot_id in self.active_bots:\n            raise HTTPException(status_code=400, detail="Bot already running")\n        \n        # Create bot instance based on type\n        if bot_type == BotType.GRID:\n            bot = GridTradingBot(bot_id, config, symbol)\n        elif bot_type == BotType.DCA:\n            bot = DCABot(bot_id, config, symbol)\n        elif bot_type == BotType.MARTINGALE:\n            bot = MartingaleBot(bot_id, config, symbol)\n        elif bot_type == BotType.ARBITRAGE:\n            bot = ArbitrageBot(bot_id, config, symbol)\n        elif bot_type == BotType.MARKET_MAKING:\n            bot = MarketMakingBot(bot_id, config, symbol)\n        else:\n            raise HTTPException(status_code=400, detail="Unsupported bot type")\n        \n        self.active_bots[bot_id] = bot\n        \n        # Start bot execution task\n        task = asyncio.create_task(self._run_bot(bot_id, bot, db))\n        self.bot_tasks[bot_id] = task\n        \n        # Update bot status\n        db_bot = db.query(TradingBot).filter(TradingBot.id == bot_id).first()\n        db_bot.status = BotStatus.RUNNING\n        db_bot.started_at = datetime.now()\n        db.commit()\n        \n        logger.info(f"Started bot {bot_id} of type {bot_type}")\n    \n    async def stop_bot(self, bot_id: int, db: Session):\n        """Stop a trading bot"""\n        if bot_id not in self.active_bots:\n            raise HTTPException(status_code=404, detail="Bot not found or not running")\n        \n        # Cancel bot task\n        if bot_id in self.bot_tasks:\n            self.bot_tasks[bot_id].cancel()\n            del self.bot_tasks[bot_id]\n        \n        # Remove from active bots\n        del self.active_bots[bot_id]\n        \n        # Update bot status\n        db_bot = db.query(TradingBot).filter(TradingBot.id == bot_id).first()\n        db_bot.status = BotStatus.STOPPED\n        db_bot.stopped_at = datetime.now()\n        db.commit()\n        \n        logger.info(f"Stopped bot {bot_id}")\n    \n    async def _run_bot(self, bot_id: int, bot: Any, db: Session):\n        """Run bot execution loop"""\n        try:\n            while True:\n                # Get current market price\n                # This would call the market data service\n                current_price = await self._get_current_price(bot.symbol)\n                \n                # Execute bot strategy\n                if isinstance(bot, GridTradingBot):\n                    orders = await bot.execute(current_price)\n                    # Process orders\n                elif isinstance(bot, DCABot):\n                    result = await bot.execute(current_price)\n                    # Process result\n                elif isinstance(bot, MartingaleBot):\n                    result = await bot.execute(current_price, "win")  # Placeholder\n                    # Process result\n                elif isinstance(bot, MarketMakingBot):\n                    orders = await bot.execute(current_price, {})\n                    # Process orders\n                \n                # Update bot performance\n                await self._update_performance(bot_id, db)\n                \n                # Sleep before next iteration\n                await asyncio.sleep(1)\n                \n        except asyncio.CancelledError:\n            logger.info(f"Bot {bot_id} execution cancelled")\n        except Exception as e:\n            logger.error(f"Error in bot {bot_id}: {str(e)}")\n            db_bot = db.query(TradingBot).filter(TradingBot.id == bot_id).first()\n            db_bot.status = BotStatus.ERROR\n            db.commit()\n    \n    async def _get_current_price(self, symbol: str) -> float:\n        """Get current market price"""\n        # This would call the market data service\n        # Placeholder implementation\n        return 50000.0\n    \n    async def _update_performance(self, bot_id: int, db: Session):\n        """Update bot performance metrics"""\n        # Calculate and store performance metrics\n        pass\n\n# Initialize bot manager\nbot_manager = BotManager()\n\n# API Endpoints\n@app.get("/health")\nasync def health_check():\n    """Health check endpoint"""\n    return {\n        "status": "healthy",\n        "service": "trading-bots-service",\n        "version": "1.0.0"\n    }\n\n@app.post("/api/v1/bots/create", response_model=BotResponse)\nasync def create_bot(\n    request: CreateBotRequest,\n    user_id: int = 1,  # TODO: Get from auth\n    db: Session = Depends(get_db)\n):\n    """Create a new trading bot"""\n    try:\n        # Create bot in database\n        db_bot = TradingBot(\n            user_id=user_id,\n            bot_type=request.bot_type,\n            name=request.name,\n            symbol=request.symbol,\n            config=request.config.dict(),\n            status=BotStatus.CREATED\n        )\n        \n        db.add(db_bot)\n        db.commit()\n        db.refresh(db_bot)\n        \n        logger.info(f"Created bot {db_bot.id} for user {user_id}")\n        \n        return BotResponse(\n            id=db_bot.id,\n            user_id=db_bot.user_id,\n            bot_type=db_bot.bot_type,\n            name=db_bot.name,\n            symbol=db_bot.symbol,\n            config=db_bot.config,\n            status=db_bot.status,\n            total_profit=db_bot.total_profit,\n            total_trades=db_bot.total_trades,\n            win_rate=db_bot.win_rate,\n            created_at=db_bot.created_at,\n            started_at=db_bot.started_at,\n            stopped_at=db_bot.stopped_at\n        )\n        \n    except Exception as e:\n        logger.error(f"Error creating bot: {str(e)}")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get("/api/v1/bots/list")\nasync def list_bots(\n    user_id: int = 1,  # TODO: Get from auth\n    status: Optional[BotStatus] = None,\n    db: Session = Depends(get_db)\n):\n    """List all bots for a user"""\n    query = db.query(TradingBot).filter(TradingBot.user_id == user_id)\n    \n    if status:\n        query = query.filter(TradingBot.status == status)\n    \n    bots = query.all()\n    \n    return {\n        "bots": [\n            BotResponse(\n                id=bot.id,\n                user_id=bot.user_id,\n                bot_type=bot.bot_type,\n                name=bot.name,\n                symbol=bot.symbol,\n                config=bot.config,\n                status=bot.status,\n                total_profit=bot.total_profit,\n                total_trades=bot.total_trades,\n                win_rate=bot.win_rate,\n                created_at=bot.created_at,\n                started_at=bot.started_at,\n                stopped_at=bot.stopped_at\n            )\n            for bot in bots\n        ]\n    }\n\n@app.get("/api/v1/bots/{bot_id}", response_model=BotResponse)\nasync def get_bot(\n    bot_id: int,\n    user_id: int = 1,  # TODO: Get from auth\n    db: Session = Depends(get_db)\n):\n    """Get bot details"""\n    bot = db.query(TradingBot).filter(\n        TradingBot.id == bot_id,\n        TradingBot.user_id == user_id\n    ).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    return BotResponse(\n        id=bot.id,\n        user_id=bot.user_id,\n        bot_type=bot.bot_type,\n        name=bot.name,\n        symbol=bot.symbol,\n        config=bot.config,\n        status=bot.status,\n        total_profit=bot.total_profit,\n        total_trades=bot.total_trades,\n        win_rate=bot.win_rate,\n        created_at=bot.created_at,\n        started_at=bot.started_at,\n        stopped_at=bot.stopped_at\n    )\n\n@app.post("/api/v1/bots/{bot_id}/start")\nasync def start_bot(\n    bot_id: int,\n    user_id: int = 1,  # TODO: Get from auth\n    db: Session = Depends(get_db)\n):\n    """Start a trading bot"""\n    bot = db.query(TradingBot).filter(\n        TradingBot.id == bot_id,\n        TradingBot.user_id == user_id\n    ).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    if bot.status == BotStatus.RUNNING:\n        raise HTTPException(status_code=400, detail="Bot is already running")\n    \n    # Start bot\n    config = BotConfig(**bot.config)\n    await bot_manager.start_bot(bot_id, bot.bot_type, config, bot.symbol, db)\n    \n    return {"message": "Bot started successfully", "bot_id": bot_id}\n\n@app.post("/api/v1/bots/{bot_id}/stop")\nasync def stop_bot(\n    bot_id: int,\n    user_id: int = 1,  # TODO: Get from auth\n    db: Session = Depends(get_db)\n):\n    """Stop a trading bot"""\n    bot = db.query(TradingBot).filter(\n        TradingBot.id == bot_id,\n        TradingBot.user_id == user_id\n    ).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    # Stop bot\n    await bot_manager.stop_bot(bot_id, db)\n    \n    return {"message": "Bot stopped successfully", "bot_id": bot_id}\n\n@app.delete("/api/v1/bots/{bot_id}")\nasync def delete_bot(\n    bot_id: int,\n    user_id: int = 1,  # TODO: Get from auth\n    db: Session = Depends(get_db)\n):\n    """Delete a trading bot"""\n    bot = db.query(TradingBot).filter(\n        TradingBot.id == bot_id,\n        TradingBot.user_id == user_id\n    ).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    # Stop bot if running\n    if bot.status == BotStatus.RUNNING:\n        await bot_manager.stop_bot(bot_id, db)\n    \n    # Delete bot\n    db.delete(bot)\n    db.commit()\n    \n    return {"message": "Bot deleted successfully", "bot_id": bot_id}\n\n@app.get("/api/v1/bots/{bot_id}/performance", response_model=BotPerformanceResponse)\nasync def get_bot_performance(\n    bot_id: int,\n    user_id: int = 1,  # TODO: Get from auth\n    db: Session = Depends(get_db)\n):\n    """Get bot performance metrics"""\n    bot = db.query(TradingBot).filter(\n        TradingBot.id == bot_id,\n        TradingBot.user_id == user_id\n    ).first()\n    \n    if not bot:\n        raise HTTPException(status_code=404, detail="Bot not found")\n    \n    # Get trades\n    trades = db.query(BotTrade).filter(BotTrade.bot_id == bot_id).all()\n    \n    # Get performance history\n    performance = db.query(BotPerformance).filter(\n        BotPerformance.bot_id == bot_id\n    ).order_by(BotPerformance.timestamp.desc()).limit(100).all()\n    \n    # Calculate metrics\n    total_value = sum(trade.quantity * trade.price for trade in trades)\n    profit_loss = bot.total_profit\n    roi = (profit_loss / total_value * 100) if total_value > 0 else 0\n    \n    return BotPerformanceResponse(\n        bot_id=bot_id,\n        total_value=total_value,\n        profit_loss=profit_loss,\n        roi=roi,\n        sharpe_ratio=0.0,  # TODO: Calculate\n        max_drawdown=0.0,  # TODO: Calculate\n        trades=[\n            {\n                "id": trade.id,\n                "symbol": trade.symbol,\n                "side": trade.side,\n                "price": trade.price,\n                "quantity": trade.quantity,\n                "profit_loss": trade.profit_loss,\n                "created_at": trade.created_at.isoformat()\n            }\n            for trade in trades\n        ],\n        performance_history=[\n            {\n                "timestamp": perf.timestamp.isoformat(),\n                "total_value": perf.total_value,\n                "profit_loss": perf.profit_loss,\n                "roi": perf.roi\n            }\n            for perf in performance\n        ]\n    )\n\n@app.get("/api/v1/bots/types")\nasync def get_bot_types():\n    """Get available bot types and their descriptions"""\n    return {\n        "bot_types": [\n            {\n                "type": "grid",\n                "name": "Grid Trading Bot",\n                "description": "Places buy and sell orders at regular intervals in a price range",\n                "parameters": ["grid_levels", "price_range_low", "price_range_high", "investment_amount"]\n            },\n            {\n                "type": "dca",\n                "name": "DCA Bot",\n                "description": "Dollar-cost averaging strategy that buys at regular intervals",\n                "parameters": ["dca_interval", "dca_amount", "target_profit"]\n            },\n            {\n                "type": "martingale",\n                "name": "Martingale Bot",\n                "description": "Doubles position size after losses to recover",\n                "parameters": ["initial_amount", "multiplier", "max_orders"]\n            },\n            {\n                "type": "arbitrage",\n                "name": "Arbitrage Bot",\n                "description": "Exploits price differences across exchanges",\n                "parameters": ["exchanges", "min_profit_percentage"]\n            },\n            {\n                "type": "market_making",\n                "name": "Market Making Bot",\n                "description": "Provides liquidity by placing buy and sell orders",\n                "parameters": ["spread_percentage", "order_amount", "max_position"]\n            }\n        ]\n    }\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8110)\n</create-file>\n</function_calls>'}